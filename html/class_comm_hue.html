<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Corluma: CommHue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CSS_Corluma.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Corluma
   &#160;<span id="projectnumber">v0.10.15</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_comm_hue-members.html">List of all members</a> &#124;
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">CommHue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_comm_hue.html" title="The CommHue class communicates with a Phillips Hue Bridge to control all of the currently connected H...">CommHue</a> class communicates with a Phillips Hue Bridge to control all of the currently connected Hue Lights.  
 <a href="class_comm_hue.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="commhue_8h_source.html">commhue.h</a>&quot;</code></p>

<p>Inherits <a class="el" href="class_comm_type.html">CommType</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr class="memitem:acbdf6a9d59c217d618301b2a0ba40327"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#acbdf6a9d59c217d618301b2a0ba40327">brightnessChange</a> (int deviceIndex, int brightness)</td></tr>
<tr class="memdesc:acbdf6a9d59c217d618301b2a0ba40327"><td class="mdescLeft">&#160;</td><td class="mdescRight">brightnessChange connected to <a class="el" href="class_comm_packet_parser.html" title="The CommPacketParser class takes the packets used for communication with other devices as input...">CommPacketParser</a>, this changes the brightness of a device.  <a href="#acbdf6a9d59c217d618301b2a0ba40327">More...</a><br /></td></tr>
<tr class="separator:acbdf6a9d59c217d618301b2a0ba40327"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:a75205a9dd6e81b970b1313402b656736"><td class="memItemLeft" align="right" valign="top"><a id="a75205a9dd6e81b970b1313402b656736"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a75205a9dd6e81b970b1313402b656736">stateChanged</a> ()</td></tr>
<tr class="memdesc:a75205a9dd6e81b970b1313402b656736"><td class="mdescLeft">&#160;</td><td class="mdescRight">stateChanged emitted when any of the lights change in any way. <br /></td></tr>
<tr class="separator:a75205a9dd6e81b970b1313402b656736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header signals_class_comm_type"><td colspan="2" onclick="javascript:toggleInherit('signals_class_comm_type')"><img src="closed.png" alt="-"/>&#160;Signals inherited from <a class="el" href="class_comm_type.html">CommType</a></td></tr>
<tr class="memitem:a9186f5c260b29ec24d0e1666191afbf6 inherit signals_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a9186f5c260b29ec24d0e1666191afbf6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a9186f5c260b29ec24d0e1666191afbf6">packetReceived</a> (QString, QString, int)</td></tr>
<tr class="memdesc:a9186f5c260b29ec24d0e1666191afbf6 inherit signals_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">packetReceived emitted whenever a packet that is not a discovery packet is received. Contains the full packet's contents as a QString. <br /></td></tr>
<tr class="separator:a9186f5c260b29ec24d0e1666191afbf6 inherit signals_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61ed4af1b52a921138f7f97e5d15b9e inherit signals_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="ac61ed4af1b52a921138f7f97e5d15b9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ac61ed4af1b52a921138f7f97e5d15b9e">updateReceived</a> (int)</td></tr>
<tr class="memdesc:ac61ed4af1b52a921138f7f97e5d15b9e inherit signals_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateReceived an update packet was received from any controller. <br /></td></tr>
<tr class="separator:ac61ed4af1b52a921138f7f97e5d15b9e inherit signals_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6437a21abfd54172305bd1eda8c52845"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a6437a21abfd54172305bd1eda8c52845">CommHue</a> ()</td></tr>
<tr class="memdesc:a6437a21abfd54172305bd1eda8c52845"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_comm_hue.html" title="The CommHue class communicates with a Phillips Hue Bridge to control all of the currently connected H...">CommHue</a> Constructor.  <a href="#a6437a21abfd54172305bd1eda8c52845">More...</a><br /></td></tr>
<tr class="separator:a6437a21abfd54172305bd1eda8c52845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d74852b7183e5fb0ffb77816969bee"><td class="memItemLeft" align="right" valign="top"><a id="a29d74852b7183e5fb0ffb77816969bee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a29d74852b7183e5fb0ffb77816969bee">~CommHue</a> ()</td></tr>
<tr class="memdesc:a29d74852b7183e5fb0ffb77816969bee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_comm_hue.html" title="The CommHue class communicates with a Phillips Hue Bridge to control all of the currently connected H...">CommHue</a> Deconstructor. <br /></td></tr>
<tr class="separator:a29d74852b7183e5fb0ffb77816969bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d07b03566ff1f1bba48c95ccb04560f"><td class="memItemLeft" align="right" valign="top"><a id="a5d07b03566ff1f1bba48c95ccb04560f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a5d07b03566ff1f1bba48c95ccb04560f">startup</a> ()</td></tr>
<tr class="memdesc:a5d07b03566ff1f1bba48c95ccb04560f"><td class="mdescLeft">&#160;</td><td class="mdescRight">startup defined in <a class="el" href="class_comm_type.html" title="inherited by comm types, provides a general interface that can be used to do connections and sending ...">CommType</a> <br /></td></tr>
<tr class="separator:a5d07b03566ff1f1bba48c95ccb04560f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcd223b12613b92a682a2c8b50f17a6"><td class="memItemLeft" align="right" valign="top"><a id="acdcd223b12613b92a682a2c8b50f17a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#acdcd223b12613b92a682a2c8b50f17a6">shutdown</a> ()</td></tr>
<tr class="memdesc:acdcd223b12613b92a682a2c8b50f17a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">shutdown defined in <a class="el" href="class_comm_type.html" title="inherited by comm types, provides a general interface that can be used to do connections and sending ...">CommType</a> <br /></td></tr>
<tr class="separator:acdcd223b12613b92a682a2c8b50f17a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39706ac1161e2b4787f9e29848953fa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a39706ac1161e2b4787f9e29848953fa1">changeColorRGB</a> (int lightIndex, int saturation, int brightness, int hue)</td></tr>
<tr class="memdesc:a39706ac1161e2b4787f9e29848953fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">changeColorRGB send a packet to a hue bridge to change the color of a given hue light.  <a href="#a39706ac1161e2b4787f9e29848953fa1">More...</a><br /></td></tr>
<tr class="separator:a39706ac1161e2b4787f9e29848953fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bd2ad9af191059d11ab1a7dc36efd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#aa3bd2ad9af191059d11ab1a7dc36efd9">changeColorCT</a> (int lightIndex, int brightness, int ct)</td></tr>
<tr class="memdesc:aa3bd2ad9af191059d11ab1a7dc36efd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">changeAmbientLight changes the color of the bulb to match the color temperature given. This is the only way to interact with white ambiance bulbs and it can also be used with the RGB bulbs.  <a href="#aa3bd2ad9af191059d11ab1a7dc36efd9">More...</a><br /></td></tr>
<tr class="separator:aa3bd2ad9af191059d11ab1a7dc36efd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e58e5e30432d41ec5db8629aa96003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#ad7e58e5e30432d41ec5db8629aa96003">turnOn</a> (int lightIndex)</td></tr>
<tr class="memdesc:ad7e58e5e30432d41ec5db8629aa96003"><td class="mdescLeft">&#160;</td><td class="mdescRight">turnOn turns on the Hue light at a given index  <a href="#ad7e58e5e30432d41ec5db8629aa96003">More...</a><br /></td></tr>
<tr class="separator:ad7e58e5e30432d41ec5db8629aa96003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a5ac47af072e9573f4349552de3b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a14a5ac47af072e9573f4349552de3b8a">turnOff</a> (int lightIndex)</td></tr>
<tr class="memdesc:a14a5ac47af072e9573f4349552de3b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">turnOff turns off the Hue light at a given index  <a href="#a14a5ac47af072e9573f4349552de3b8a">More...</a><br /></td></tr>
<tr class="separator:a14a5ac47af072e9573f4349552de3b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff41ac21bb508ba33f0402e5ab57b5"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_s_hue_light.html">SHueLight</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a57ff41ac21bb508ba33f0402e5ab57b5">connectedHues</a> ()</td></tr>
<tr class="memdesc:a57ff41ac21bb508ba33f0402e5ab57b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">connectedHues returns vector of the currently connected Hue lights. Used by the settings page to display the list.  <a href="#a57ff41ac21bb508ba33f0402e5ab57b5">More...</a><br /></td></tr>
<tr class="separator:a57ff41ac21bb508ba33f0402e5ab57b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88f3e48667d971fcfb337a06fce28b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_hue_bridge_discovery.html">HueBridgeDiscovery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#ae88f3e48667d971fcfb337a06fce28b7">discovery</a> ()</td></tr>
<tr class="memdesc:ae88f3e48667d971fcfb337a06fce28b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">discovery returns a pointer to the object used to discover the Hue Bridge. This can be used to connect to its signals or to check its current state.  <a href="#ae88f3e48667d971fcfb337a06fce28b7">More...</a><br /></td></tr>
<tr class="separator:ae88f3e48667d971fcfb337a06fce28b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ea74e3a990f775cf9c9f5188370c49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#aa0ea74e3a990f775cf9c9f5188370c49">sendPacket</a> (<a class="el" href="struct_s_device_controller.html">SDeviceController</a> controller, QString packet)</td></tr>
<tr class="memdesc:aa0ea74e3a990f775cf9c9f5188370c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">sendPacket Takes a packet in the format of a Corluma lights command (a comma delimited QString) and converts it into a Phillips Hue command  <a href="#aa0ea74e3a990f775cf9c9f5188370c49">More...</a><br /></td></tr>
<tr class="separator:aa0ea74e3a990f775cf9c9f5188370c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dfaf04e9d6f01b3bee479cf0a6d3e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_hue_light.html">SHueLight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a84dfaf04e9d6f01b3bee479cf0a6d3e3">hueLightFromLightDevice</a> (const SLightDevice &amp;device)</td></tr>
<tr class="memdesc:a84dfaf04e9d6f01b3bee479cf0a6d3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">hueLightFromLightDevice For every SLightDevice with type hue, there is a <a class="el" href="struct_s_hue_light.html" title="The SHueLight struct a struct that stores all the relevant data received from a state update from the...">SHueLight</a> that represents the same device. The <a class="el" href="struct_s_hue_light.html" title="The SHueLight struct a struct that stores all the relevant data received from a state update from the...">SHueLight</a> contains hue-specific information such as the bulb's software version and model ID. This information This function takes the SLightDevice and returns the mapped <a class="el" href="struct_s_hue_light.html" title="The SHueLight struct a struct that stores all the relevant data received from a state update from the...">SHueLight</a>  <a href="#a84dfaf04e9d6f01b3bee479cf0a6d3e3">More...</a><br /></td></tr>
<tr class="separator:a84dfaf04e9d6f01b3bee479cf0a6d3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae090b9b2f2ab6d3e47c45d91433c6895"><td class="memItemLeft" align="right" valign="top">SLightDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#ae090b9b2f2ab6d3e47c45d91433c6895">lightDeviceFromHueLight</a> (const <a class="el" href="struct_s_hue_light.html">SHueLight</a> &amp;light)</td></tr>
<tr class="memdesc:ae090b9b2f2ab6d3e47c45d91433c6895"><td class="mdescLeft">&#160;</td><td class="mdescRight">lightDeviceFromHueLight create a light device based off of the data provided in a <a class="el" href="struct_s_hue_light.html" title="The SHueLight struct a struct that stores all the relevant data received from a state update from the...">SHueLight</a>  <a href="#ae090b9b2f2ab6d3e47c45d91433c6895">More...</a><br /></td></tr>
<tr class="separator:ae090b9b2f2ab6d3e47c45d91433c6895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b80833f0f35e62ea27427c139379fa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a8b80833f0f35e62ea27427c139379fa7">sendSchedule</a> (<a class="el" href="struct_s_hue_schedule.html">SHueSchedule</a> schedule)</td></tr>
<tr class="memdesc:a8b80833f0f35e62ea27427c139379fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">sendSchedule send a schedule to the Hue Bridge. This schedule gets kept on the bridge and will not be deleted unless explicitly asked to be deleted.  <a href="#a8b80833f0f35e62ea27427c139379fa7">More...</a><br /></td></tr>
<tr class="separator:a8b80833f0f35e62ea27427c139379fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12170f5466d258751a228029ac7aedd"><td class="memItemLeft" align="right" valign="top"><a id="ac12170f5466d258751a228029ac7aedd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#ac12170f5466d258751a228029ac7aedd">stopBackgroundTimers</a> ()</td></tr>
<tr class="memdesc:ac12170f5466d258751a228029ac7aedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop the timers that sync things like schedules and groups in the background. <br /></td></tr>
<tr class="separator:ac12170f5466d258751a228029ac7aedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10504c9e160b93d89544ec5191de6cc3"><td class="memItemLeft" align="right" valign="top"><a id="a10504c9e160b93d89544ec5191de6cc3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a10504c9e160b93d89544ec5191de6cc3">createIdleTimeoutsForConnectedLights</a> ()</td></tr>
<tr class="memdesc:a10504c9e160b93d89544ec5191de6cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">createIdleTimeoutsForConnectedLights Hue lights don't have a default idle timeout option, RGB-LED-Routines lights do. What do!? We create a schedule that maps to each light individually, and after packets are done syncing if a timeout is enabled, the schedule is updated. <br /></td></tr>
<tr class="separator:a10504c9e160b93d89544ec5191de6cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0fbc05c68eae8656ccf9ae2a2d1753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a2b0fbc05c68eae8656ccf9ae2a2d1753">createIdleTimeout</a> (int i, int minutes)</td></tr>
<tr class="memdesc:a2b0fbc05c68eae8656ccf9ae2a2d1753"><td class="mdescLeft">&#160;</td><td class="mdescRight">createIdleTimeout create an idle timeout schedule for a specific light.  <a href="#a2b0fbc05c68eae8656ccf9ae2a2d1753">More...</a><br /></td></tr>
<tr class="separator:a2b0fbc05c68eae8656ccf9ae2a2d1753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6073064325473abf0459a3cdea3bde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a3b6073064325473abf0459a3cdea3bde">postJson</a> (QString resource, QJsonObject object)</td></tr>
<tr class="memdesc:a3b6073064325473abf0459a3cdea3bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">postJson helper function that takes a JSON object and posts it to the hue bridge.  <a href="#a3b6073064325473abf0459a3cdea3bde">More...</a><br /></td></tr>
<tr class="separator:a3b6073064325473abf0459a3cdea3bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5401aeb2a77f24454d55d4a2914ad488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a5401aeb2a77f24454d55d4a2914ad488">putJson</a> (QString resource, QJsonObject object)</td></tr>
<tr class="memdesc:a5401aeb2a77f24454d55d4a2914ad488"><td class="mdescLeft">&#160;</td><td class="mdescRight">putJson helper function that takes a JSON object and puts it on the hue bridge.  <a href="#a5401aeb2a77f24454d55d4a2914ad488">More...</a><br /></td></tr>
<tr class="separator:a5401aeb2a77f24454d55d4a2914ad488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fed02de7e4c501b076860a18ac0eba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#ae7fed02de7e4c501b076860a18ac0eba">updateIdleTimeout</a> (bool enable, int scheduleID, int minutes)</td></tr>
<tr class="memdesc:ae7fed02de7e4c501b076860a18ac0eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateIdleTimeout upate the idle tieout for a specific schedule. This is called during data sync to turn off the idle timeout and after datasync it gets called again to turn the idle timeout back on.  <a href="#ae7fed02de7e4c501b076860a18ac0eba">More...</a><br /></td></tr>
<tr class="separator:ae7fed02de7e4c501b076860a18ac0eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1b2d69fc4a3e4b4a56e8a712cf794f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_hue_bridge.html">SHueBridge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a3e1b2d69fc4a3e4b4a56e8a712cf794f">bridge</a> ()</td></tr>
<tr class="memdesc:a3e1b2d69fc4a3e4b4a56e8a712cf794f"><td class="mdescLeft">&#160;</td><td class="mdescRight">bridge getter for the bridge and its associated info  <a href="#a3e1b2d69fc4a3e4b4a56e8a712cf794f">More...</a><br /></td></tr>
<tr class="separator:a3e1b2d69fc4a3e4b4a56e8a712cf794f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2197131a6b7dabef3b406bee54ab64"><td class="memItemLeft" align="right" valign="top">QJsonObject&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#acc2197131a6b7dabef3b406bee54ab64">SHueCommandToJsonObject</a> (<a class="el" href="struct_s_hue_command.html">SHueCommand</a> command)</td></tr>
<tr class="memdesc:acc2197131a6b7dabef3b406bee54ab64"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHueCommandToJsonObject converts a <a class="el" href="struct_s_hue_command.html" title="The SHueCommand struct command sent to a hue bridge. ">SHueCommand</a> into a Json object that can be sent to a hue as a command. Neat!  <a href="#acc2197131a6b7dabef3b406bee54ab64">More...</a><br /></td></tr>
<tr class="separator:acc2197131a6b7dabef3b406bee54ab64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da488093965bb26bb79b4b98a92ba66"><td class="memItemLeft" align="right" valign="top">QJsonObject&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a4da488093965bb26bb79b4b98a92ba66">SLightDeviceToJsonObject</a> (SLightDevice device)</td></tr>
<tr class="memdesc:a4da488093965bb26bb79b4b98a92ba66"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLightDeviceToJsonObject a SLightDevice to convert into a light representation in json.  <a href="#a4da488093965bb26bb79b4b98a92ba66">More...</a><br /></td></tr>
<tr class="separator:a4da488093965bb26bb79b4b98a92ba66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28bde55a1bbc9aad0088f0a9ca379cb"><td class="memItemLeft" align="right" valign="top"><a id="af28bde55a1bbc9aad0088f0a9ca379cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#af28bde55a1bbc9aad0088f0a9ca379cb">haveGroups</a> ()</td></tr>
<tr class="memdesc:af28bde55a1bbc9aad0088f0a9ca379cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if its received any data about groups from the hue bridge, false otherwise. <br /></td></tr>
<tr class="separator:af28bde55a1bbc9aad0088f0a9ca379cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c1cee118ea718bf532fad597aeb40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#ad3c1cee118ea718bf532fad597aeb40d">createGroup</a> (QString name, std::list&lt; <a class="el" href="struct_s_hue_light.html">SHueLight</a> &gt; lights)</td></tr>
<tr class="memdesc:ad3c1cee118ea718bf532fad597aeb40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">createGroup create a new group of lights on the hue bridge  <a href="#ad3c1cee118ea718bf532fad597aeb40d">More...</a><br /></td></tr>
<tr class="separator:ad3c1cee118ea718bf532fad597aeb40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd20cb0e9daca2452b441f57a442771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a2bd20cb0e9daca2452b441f57a442771">updateGroup</a> (SHueGroup group, std::list&lt; <a class="el" href="struct_s_hue_light.html">SHueLight</a> &gt; lights)</td></tr>
<tr class="memdesc:a2bd20cb0e9daca2452b441f57a442771"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateGroup change the lights in an already-existing hue group  <a href="#a2bd20cb0e9daca2452b441f57a442771">More...</a><br /></td></tr>
<tr class="separator:a2bd20cb0e9daca2452b441f57a442771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc33dc2377b1f5c653fa93c641272a94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#afc33dc2377b1f5c653fa93c641272a94">deleteGroup</a> (SHueGroup group)</td></tr>
<tr class="memdesc:afc33dc2377b1f5c653fa93c641272a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">deleteGroup delete a group from the hue bridge  <a href="#afc33dc2377b1f5c653fa93c641272a94">More...</a><br /></td></tr>
<tr class="separator:afc33dc2377b1f5c653fa93c641272a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27891a336b97c5e4f8aaf0f12d6fc4ad"><td class="memItemLeft" align="right" valign="top"><a id="a27891a336b97c5e4f8aaf0f12d6fc4ad"></a>
std::list&lt; SHueGroup &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a27891a336b97c5e4f8aaf0f12d6fc4ad">groups</a> ()</td></tr>
<tr class="memdesc:a27891a336b97c5e4f8aaf0f12d6fc4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for list of groups <br /></td></tr>
<tr class="separator:a27891a336b97c5e4f8aaf0f12d6fc4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6768c5f60f4f675e6999b0e923fc1886"><td class="memItemLeft" align="right" valign="top"><a id="a6768c5f60f4f675e6999b0e923fc1886"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a6768c5f60f4f675e6999b0e923fc1886">haveSchedules</a> ()</td></tr>
<tr class="memdesc:a6768c5f60f4f675e6999b0e923fc1886"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if its received any data about schedules from the hue bridge, false otherwise. <br /></td></tr>
<tr class="separator:a6768c5f60f4f675e6999b0e923fc1886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099b9b4c0fa13a28de49858c4043afbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a099b9b4c0fa13a28de49858c4043afbc">createSchedule</a> (QString name, QString description, <a class="el" href="struct_s_hue_command.html">SHueCommand</a> command, QString localtime)</td></tr>
<tr class="memdesc:a099b9b4c0fa13a28de49858c4043afbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">createSchedule create a hue schedule to be stored on the bridge  <a href="#a099b9b4c0fa13a28de49858c4043afbc">More...</a><br /></td></tr>
<tr class="separator:a099b9b4c0fa13a28de49858c4043afbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bceccaa3425c88f9f971a74423d4dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a76bceccaa3425c88f9f971a74423d4dd">updateSchedule</a> (<a class="el" href="struct_s_hue_schedule.html">SHueSchedule</a> schedule, <a class="el" href="struct_s_hue_schedule.html">SHueSchedule</a> newSchedule)</td></tr>
<tr class="memdesc:a76bceccaa3425c88f9f971a74423d4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateSchedule update a hue schedule with new information  <a href="#a76bceccaa3425c88f9f971a74423d4dd">More...</a><br /></td></tr>
<tr class="separator:a76bceccaa3425c88f9f971a74423d4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de7a0ee906a9ecf1f4dd32208ecdea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a3de7a0ee906a9ecf1f4dd32208ecdea7">deleteSchedule</a> (<a class="el" href="struct_s_hue_schedule.html">SHueSchedule</a> schedule)</td></tr>
<tr class="memdesc:a3de7a0ee906a9ecf1f4dd32208ecdea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">deleteSchedule delete a hue schedule from the bridge  <a href="#a3de7a0ee906a9ecf1f4dd32208ecdea7">More...</a><br /></td></tr>
<tr class="separator:a3de7a0ee906a9ecf1f4dd32208ecdea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b39a6fa768af92c308428a2f597e649"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_s_hue_schedule.html">SHueSchedule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a9b39a6fa768af92c308428a2f597e649">schedules</a> ()</td></tr>
<tr class="memdesc:a9b39a6fa768af92c308428a2f597e649"><td class="mdescLeft">&#160;</td><td class="mdescRight">schedules getter for a list of all known schedules  <a href="#a9b39a6fa768af92c308428a2f597e649">More...</a><br /></td></tr>
<tr class="separator:a9b39a6fa768af92c308428a2f597e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95720c743b01d411710d7a500c2042b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a95720c743b01d411710d7a500c2042b2">searchForNewLights</a> (std::list&lt; QString &gt; serialNumbers=std::list&lt; QString &gt;())</td></tr>
<tr class="memdesc:a95720c743b01d411710d7a500c2042b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">searchForNewLights search for new lights that havent been paired with the bridge yet  <a href="#a95720c743b01d411710d7a500c2042b2">More...</a><br /></td></tr>
<tr class="separator:a95720c743b01d411710d7a500c2042b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebc296975e29ab154eebbff9054c58a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a6ebc296975e29ab154eebbff9054c58a">renameLight</a> (<a class="el" href="struct_s_hue_light.html">SHueLight</a> light, QString newName)</td></tr>
<tr class="memdesc:a6ebc296975e29ab154eebbff9054c58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">renameLight rename the light's name stored on the hue bridge.  <a href="#a6ebc296975e29ab154eebbff9054c58a">More...</a><br /></td></tr>
<tr class="separator:a6ebc296975e29ab154eebbff9054c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602fc8ae2373378eaf1d528577d5d8cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_hue.html#a602fc8ae2373378eaf1d528577d5d8cd">deleteLight</a> (<a class="el" href="struct_s_hue_light.html">SHueLight</a> light)</td></tr>
<tr class="memdesc:a602fc8ae2373378eaf1d528577d5d8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">deleteLight delete the light and its stored data from the bridge  <a href="#a602fc8ae2373378eaf1d528577d5d8cd">More...</a><br /></td></tr>
<tr class="separator:a602fc8ae2373378eaf1d528577d5d8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_comm_type"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_comm_type')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_comm_type.html">CommType</a></td></tr>
<tr class="memitem:aea9af432f13faf2a28b6a9fd5d5000e9 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="aea9af432f13faf2a28b6a9fd5d5000e9"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#aea9af432f13faf2a28b6a9fd5d5000e9">~CommType</a> ()</td></tr>
<tr class="memdesc:aea9af432f13faf2a28b6a9fd5d5000e9 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">~CommType Destructor <br /></td></tr>
<tr class="separator:aea9af432f13faf2a28b6a9fd5d5000e9 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6d7465b678fc3daf1e9580d331c8dc inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ace6d7465b678fc3daf1e9580d331c8dc">hasStarted</a> ()</td></tr>
<tr class="memdesc:ace6d7465b678fc3daf1e9580d331c8dc inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">hasStarted true if startup has been called and a shutdown has not be called after it, false otherwise.  <a href="class_comm_type.html#ace6d7465b678fc3daf1e9580d331c8dc">More...</a><br /></td></tr>
<tr class="separator:ace6d7465b678fc3daf1e9580d331c8dc inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee085c089155c088acd4ebb4ed41b4f inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a3ee085c089155c088acd4ebb4ed41b4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a3ee085c089155c088acd4ebb4ed41b4f">startDiscovery</a> ()</td></tr>
<tr class="memdesc:a3ee085c089155c088acd4ebb4ed41b4f inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">startDiscovery start sending discovery packets if needed, and continually request state update packets. <br /></td></tr>
<tr class="separator:a3ee085c089155c088acd4ebb4ed41b4f inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e83c722a3afb0c1ceda26c55c76e85 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="ab0e83c722a3afb0c1ceda26c55c76e85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ab0e83c722a3afb0c1ceda26c55c76e85">stopDiscovery</a> ()</td></tr>
<tr class="memdesc:ab0e83c722a3afb0c1ceda26c55c76e85 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">stopDiscovery stop sending discovery packets and go back to requesting state update packets only when in use. <br /></td></tr>
<tr class="separator:ab0e83c722a3afb0c1ceda26c55c76e85 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b5c67a3a87429a342fb9e82cdcaf6d inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ab5b5c67a3a87429a342fb9e82cdcaf6d">runningDiscovery</a> ()</td></tr>
<tr class="memdesc:ab5b5c67a3a87429a342fb9e82cdcaf6d inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">runningDiscovery true if theres any controller that is going through the discovery routines and hasn't been discovered, false otherwise.  <a href="class_comm_type.html#ab5b5c67a3a87429a342fb9e82cdcaf6d">More...</a><br /></td></tr>
<tr class="separator:ab5b5c67a3a87429a342fb9e82cdcaf6d inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92c228926c3214a78e12d3519102555 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="ae92c228926c3214a78e12d3519102555"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ae92c228926c3214a78e12d3519102555">resetStateUpdateTimeout</a> ()</td></tr>
<tr class="memdesc:ae92c228926c3214a78e12d3519102555 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">resetStateUpdateTimeout reset the timer tracking when to shutdown the state update thread. <br /></td></tr>
<tr class="separator:ae92c228926c3214a78e12d3519102555 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684c569bb57248ae4b0b2e4563339f74 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a684c569bb57248ae4b0b2e4563339f74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a684c569bb57248ae4b0b2e4563339f74">stopStateUpdates</a> ()</td></tr>
<tr class="memdesc:a684c569bb57248ae4b0b2e4563339f74 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">stopStateUpdates turn off the state update timers. <br /></td></tr>
<tr class="separator:a684c569bb57248ae4b0b2e4563339f74 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bed4ee74af1ae3a9b5d007fe878524 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a92bed4ee74af1ae3a9b5d007fe878524">startDiscoveringController</a> (QString controller)</td></tr>
<tr class="memdesc:a92bed4ee74af1ae3a9b5d007fe878524 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">startDiscoveringController attempts to add a new controller to the device table.  <a href="class_comm_type.html#a92bed4ee74af1ae3a9b5d007fe878524">More...</a><br /></td></tr>
<tr class="separator:a92bed4ee74af1ae3a9b5d007fe878524 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92edbc5226b05f4767a8650ac713ac5 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ae92edbc5226b05f4767a8650ac713ac5">removeController</a> (<a class="el" href="struct_s_device_controller.html">SDeviceController</a> controller)</td></tr>
<tr class="memdesc:ae92edbc5226b05f4767a8650ac713ac5 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">removeController attempts to remove the controller from the device table.  <a href="class_comm_type.html#ae92edbc5226b05f4767a8650ac713ac5">More...</a><br /></td></tr>
<tr class="separator:ae92edbc5226b05f4767a8650ac713ac5 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af821394409188dff6275f2810ca799ad inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#af821394409188dff6275f2810ca799ad">updateDevice</a> (SLightDevice device)</td></tr>
<tr class="memdesc:af821394409188dff6275f2810ca799ad inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateDevice update all the data in the light device that matches the same controller and index. if a light device doesn't exist with these properties, then it creates a new one.  <a href="class_comm_type.html#af821394409188dff6275f2810ca799ad">More...</a><br /></td></tr>
<tr class="separator:af821394409188dff6275f2810ca799ad inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d82da9a4b796ccb66d9d5c155e082e1 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a4d82da9a4b796ccb66d9d5c155e082e1">fillDevice</a> (SLightDevice &amp;device)</td></tr>
<tr class="memdesc:a4d82da9a4b796ccb66d9d5c155e082e1 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">fillDevice takes the controller and index of the referenced SLightDevice and overwrites all other values with the values stored in the device table.  <a href="class_comm_type.html#a4d82da9a4b796ccb66d9d5c155e082e1">More...</a><br /></td></tr>
<tr class="separator:a4d82da9a4b796ccb66d9d5c155e082e1 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1865d11bc8e1f01a925ed68e284691 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; std::string, std::list&lt; SLightDevice &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#acb1865d11bc8e1f01a925ed68e284691">deviceTable</a> ()</td></tr>
<tr class="memdesc:acb1865d11bc8e1f01a925ed68e284691 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">deviceList list of the light devices  <a href="class_comm_type.html#acb1865d11bc8e1f01a925ed68e284691">More...</a><br /></td></tr>
<tr class="separator:acb1865d11bc8e1f01a925ed68e284691 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec827112012957f7a7efb36d6fef94f inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">const std::list&lt; <a class="el" href="struct_s_device_controller.html">SDeviceController</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a1ec827112012957f7a7efb36d6fef94f">discoveredList</a> ()</td></tr>
<tr class="memdesc:a1ec827112012957f7a7efb36d6fef94f inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">discoveredList getter for list of discovered devices  <a href="class_comm_type.html#a1ec827112012957f7a7efb36d6fef94f">More...</a><br /></td></tr>
<tr class="separator:a1ec827112012957f7a7efb36d6fef94f inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a23c71147fb8b134d56969281486f2f inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">std::list&lt; QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a2a23c71147fb8b134d56969281486f2f">undiscoveredList</a> ()</td></tr>
<tr class="memdesc:a2a23c71147fb8b134d56969281486f2f inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">undiscoveredList getter for list of undiscovered devices.  <a href="class_comm_type.html#a2a23c71147fb8b134d56969281486f2f">More...</a><br /></td></tr>
<tr class="separator:a2a23c71147fb8b134d56969281486f2f inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa25ac27d5bdb85a13b8d461ca1a960c inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#aaa25ac27d5bdb85a13b8d461ca1a960c">setupConnectionList</a> (ECommType type)</td></tr>
<tr class="memdesc:aaa25ac27d5bdb85a13b8d461ca1a960c inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">setupConnectionList initializes the connection list and reloads it from system memory, if needed  <a href="class_comm_type.html#aaa25ac27d5bdb85a13b8d461ca1a960c">More...</a><br /></td></tr>
<tr class="separator:aaa25ac27d5bdb85a13b8d461ca1a960c inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf39ac1fbdab41338549ea9010ed0f91 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="acf39ac1fbdab41338549ea9010ed0f91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#acf39ac1fbdab41338549ea9010ed0f91">saveConnectionList</a> ()</td></tr>
<tr class="memdesc:acf39ac1fbdab41338549ea9010ed0f91 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">saveConnectionList must be called by deconstructors, saves the connection list to the app's persistent memory. <br /></td></tr>
<tr class="separator:acf39ac1fbdab41338549ea9010ed0f91 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947fb8ccab594d6177e861e096795414 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a947fb8ccab594d6177e861e096795414">deviceControllerFromDiscoveryString</a> (QString discovery, QString controllerName, <a class="el" href="struct_s_device_controller.html">SDeviceController</a> &amp;controller)</td></tr>
<tr class="memdesc:a947fb8ccab594d6177e861e096795414 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">deviceControllerFromDiscoveryString takes a discovery string, a controller name, and an empty <a class="el" href="struct_s_device_controller.html" title="The SDeviceController struct stores information about a Controller. A controller allows control of on...">SDeviceController</a> as input. If parsing the string is successful, it fills the <a class="el" href="struct_s_device_controller.html" title="The SDeviceController struct stores information about a Controller. A controller allows control of on...">SDeviceController</a> with the info from the discovery string. If its unsucessful, it returns false.  <a href="class_comm_type.html#a947fb8ccab594d6177e861e096795414">More...</a><br /></td></tr>
<tr class="separator:a947fb8ccab594d6177e861e096795414 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b985f6292f611420c73a5d14f29de30 inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a1b985f6292f611420c73a5d14f29de30">findDiscoveredController</a> (QString controllerName, <a class="el" href="struct_s_device_controller.html">SDeviceController</a> &amp;output)</td></tr>
<tr class="memdesc:a1b985f6292f611420c73a5d14f29de30 inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">findDiscoveredController checks for a discovered controller with the given name. Returns true and fills the <a class="el" href="struct_s_device_controller.html" title="The SDeviceController struct stores information about a Controller. A controller allows control of on...">SDeviceController</a> given as input if one is found, returns false if one isnt found  <a href="class_comm_type.html#a1b985f6292f611420c73a5d14f29de30">More...</a><br /></td></tr>
<tr class="separator:a1b985f6292f611420c73a5d14f29de30 inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7e4f61858d208f0832d737819cc93a inherit pub_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#aae7e4f61858d208f0832d737819cc93a">handleIncomingPacket</a> (QString controllerName, QString payload)</td></tr>
<tr class="memdesc:aae7e4f61858d208f0832d737819cc93a inherit pub_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">handleIncomingPacket All packets that are sent to any commtype get sent through this function to be sorted and sent to the proper subsystems.  <a href="class_comm_type.html#aae7e4f61858d208f0832d737819cc93a">More...</a><br /></td></tr>
<tr class="separator:aae7e4f61858d208f0832d737819cc93a inherit pub_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_comm_type"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_comm_type')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_comm_type.html">CommType</a></td></tr>
<tr class="memitem:a5290e848b002321ddbdf1895bb59977e inherit pro_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a5290e848b002321ddbdf1895bb59977e">preparePacketForTransmission</a> (const <a class="el" href="struct_s_device_controller.html">SDeviceController</a> &amp;controller, QString &amp;packet)</td></tr>
<tr class="memdesc:a5290e848b002321ddbdf1895bb59977e inherit pro_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">preparePacketForTransmission prepare internal states and variables for sending a new packet and adjust packet to fix issues with sending it, if needed  <a href="class_comm_type.html#a5290e848b002321ddbdf1895bb59977e">More...</a><br /></td></tr>
<tr class="separator:a5290e848b002321ddbdf1895bb59977e inherit pro_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4143fad9f0cad9b4e0efff68614bf1 inherit pro_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="adb4143fad9f0cad9b4e0efff68614bf1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#adb4143fad9f0cad9b4e0efff68614bf1">resetDiscovery</a> ()</td></tr>
<tr class="memdesc:adb4143fad9f0cad9b4e0efff68614bf1 inherit pro_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">resetDiscovery clears the throttle list and discovery list and treats the commtype as if nothing has been discovered. <br /></td></tr>
<tr class="separator:adb4143fad9f0cad9b4e0efff68614bf1 inherit pro_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140fb846eeb4d24976e2a4f514f95f0f inherit pro_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a140fb846eeb4d24976e2a4f514f95f0f">shouldContinueStateUpdate</a> ()</td></tr>
<tr class="memdesc:a140fb846eeb4d24976e2a4f514f95f0f inherit pro_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">shouldContinueStateUpdate checks internal states and determines if it should still keep requesting state updates from the devices.  <a href="class_comm_type.html#a140fb846eeb4d24976e2a4f514f95f0f">More...</a><br /></td></tr>
<tr class="separator:a140fb846eeb4d24976e2a4f514f95f0f inherit pro_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93d4f182250a259f6a551e9a77ea2a6 inherit pro_methods_class_comm_type"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ae93d4f182250a259f6a551e9a77ea2a6">handleDiscoveryPacket</a> (<a class="el" href="struct_s_device_controller.html">SDeviceController</a> sender)</td></tr>
<tr class="memdesc:ae93d4f182250a259f6a551e9a77ea2a6 inherit pro_methods_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">handleDiscoveryPacket called whenever a discovery packet is received by a commtype. Although all commtypes may received a packet in different ways or in differnt formats, all ways get converted so that they work with this function. The function determines if the device sending the discovery packet has been discovered already, and if it hasn't, it adds it to its list. It also initiates a throttle timer for this particular controller. Finally, it determines if its looking for any other controllers, and if its not, it shuts off the discovery timer.  <a href="class_comm_type.html#ae93d4f182250a259f6a551e9a77ea2a6">More...</a><br /></td></tr>
<tr class="separator:ae93d4f182250a259f6a551e9a77ea2a6 inherit pro_methods_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_comm_type"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_comm_type')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_comm_type.html">CommType</a></td></tr>
<tr class="memitem:a93d86e18ed75c62c422d727cc4e25b8c inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a93d86e18ed75c62c422d727cc4e25b8c"></a>
QTime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a93d86e18ed75c62c422d727cc4e25b8c">mLastSendTime</a></td></tr>
<tr class="memdesc:a93d86e18ed75c62c422d727cc4e25b8c inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mLastSendTime the last time a message was sent to the commtype. This is tracked to detect when the device is no longer being actively used, so it can slow down or shut off state update packets. <br /></td></tr>
<tr class="separator:a93d86e18ed75c62c422d727cc4e25b8c inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1a32e29697d8b08401a04b91921d85 inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a6c1a32e29697d8b08401a04b91921d85"></a>
<a class="el" href="class_c_r_c_calculator.html">CRCCalculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a6c1a32e29697d8b08401a04b91921d85">mCRC</a></td></tr>
<tr class="memdesc:a6c1a32e29697d8b08401a04b91921d85 inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to add CRC to outgoing packets. <br /></td></tr>
<tr class="separator:a6c1a32e29697d8b08401a04b91921d85 inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079be5b6039a73ab74f242f834702d99 inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a079be5b6039a73ab74f242f834702d99"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a079be5b6039a73ab74f242f834702d99">mStateUpdateCounter</a></td></tr>
<tr class="memdesc:a079be5b6039a73ab74f242f834702d99 inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of state updates sent out <br /></td></tr>
<tr class="separator:a079be5b6039a73ab74f242f834702d99 inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c1f60fe67e3e018ee772d8d8e7a3f8 inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ad8c1f60fe67e3e018ee772d8d8e7a3f8">mSecondaryUpdatesInterval</a></td></tr>
<tr class="separator:ad8c1f60fe67e3e018ee772d8d8e7a3f8 inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17df6d25cf2db9d844945d6f135e65c inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="ab17df6d25cf2db9d844945d6f135e65c"></a>
std::unordered_map&lt; std::string, std::list&lt; SLightDevice &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ab17df6d25cf2db9d844945d6f135e65c">mDeviceTable</a></td></tr>
<tr class="memdesc:ab17df6d25cf2db9d844945d6f135e65c inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mDeviceTable hash table of all available devices. the hash key is the controller name and the list associated with it is all known devices connected to that controller. <br /></td></tr>
<tr class="separator:ab17df6d25cf2db9d844945d6f135e65c inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ec483a63cf7b4946653ca8dea9ae46 inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a02ec483a63cf7b4946653ca8dea9ae46"></a>
std::list&lt; QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a02ec483a63cf7b4946653ca8dea9ae46">mUndiscoveredList</a></td></tr>
<tr class="memdesc:a02ec483a63cf7b4946653ca8dea9ae46 inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mUndiscoveredList list of controllers that are not currently discovered but are running discovery routines. <br /></td></tr>
<tr class="separator:a02ec483a63cf7b4946653ca8dea9ae46 inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daeb935ad4de1f56f246ae1d04157dc inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a9daeb935ad4de1f56f246ae1d04157dc"></a>
std::list&lt; <a class="el" href="struct_s_device_controller.html">SDeviceController</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a9daeb935ad4de1f56f246ae1d04157dc">mDiscoveredList</a></td></tr>
<tr class="memdesc:a9daeb935ad4de1f56f246ae1d04157dc inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mDiscoveredList list of devices that have been discovered properly. <br /></td></tr>
<tr class="separator:a9daeb935ad4de1f56f246ae1d04157dc inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad0675d5baa960558751025bc5ec3a inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a5fad0675d5baa960558751025bc5ec3a"></a>
QTimer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a5fad0675d5baa960558751025bc5ec3a">mStateUpdateTimer</a></td></tr>
<tr class="memdesc:a5fad0675d5baa960558751025bc5ec3a inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mStateUpdateTimer Polls the controller every few seconds requesting updates on all of its devices. <br /></td></tr>
<tr class="separator:a5fad0675d5baa960558751025bc5ec3a inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe98ed3a9a537c126fcebdb6ac109a09 inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="afe98ed3a9a537c126fcebdb6ac109a09"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#afe98ed3a9a537c126fcebdb6ac109a09">mStateUpdateInterval</a></td></tr>
<tr class="memdesc:afe98ed3a9a537c126fcebdb6ac109a09 inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mStateUpdateInterval number of msec between each state update request. <br /></td></tr>
<tr class="separator:afe98ed3a9a537c126fcebdb6ac109a09 inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab283071f18b76741c90a25a06e61c763 inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="ab283071f18b76741c90a25a06e61c763"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ab283071f18b76741c90a25a06e61c763">mDiscoveryUpdateInterval</a></td></tr>
<tr class="memdesc:ab283071f18b76741c90a25a06e61c763 inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mDiscoveryUpdateInterval number of msec between sending out each discovery packet. <br /></td></tr>
<tr class="separator:ab283071f18b76741c90a25a06e61c763 inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ba509a1aa972b772c1c6f8f074a1cb inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a53ba509a1aa972b772c1c6f8f074a1cb"></a>
QTimer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a53ba509a1aa972b772c1c6f8f074a1cb">mDiscoveryTimer</a></td></tr>
<tr class="memdesc:a53ba509a1aa972b772c1c6f8f074a1cb inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mDiscoveryTimer used during discovery to poll the device every few seconds. <br /></td></tr>
<tr class="separator:a53ba509a1aa972b772c1c6f8f074a1cb inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed07e124f1bb8819e0452cb2621e5629 inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="aed07e124f1bb8819e0452cb2621e5629"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#aed07e124f1bb8819e0452cb2621e5629">mUpdateTimeoutInterval</a></td></tr>
<tr class="memdesc:aed07e124f1bb8819e0452cb2621e5629 inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mUpdateTimeoutInterval number of msec that it takes the state update timer to time out and stop sending state update requests. <br /></td></tr>
<tr class="separator:aed07e124f1bb8819e0452cb2621e5629 inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc75099b138addb3dc35692e819eabe inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="afcc75099b138addb3dc35692e819eabe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#afcc75099b138addb3dc35692e819eabe">mDiscoveryMode</a></td></tr>
<tr class="memdesc:afcc75099b138addb3dc35692e819eabe inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mDiscoveryMode true if all discovery and state update threads for the commtype should be active, false if using the standard lifecyclef for all the threads. <br /></td></tr>
<tr class="separator:afcc75099b138addb3dc35692e819eabe inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8ea9e88347922939c9823e0f1488ea inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a2e8ea9e88347922939c9823e0f1488ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a2e8ea9e88347922939c9823e0f1488ea">mFullyDiscovered</a></td></tr>
<tr class="memdesc:a2e8ea9e88347922939c9823e0f1488ea inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mFullyDiscovered bool that tracks whether or not all the controllers the commtype is looking for have been discovered. This gets set to false if a discovery routine starts looking for a new controller. <br /></td></tr>
<tr class="separator:a2e8ea9e88347922939c9823e0f1488ea inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a3020ab06d49b995e22c7b4567017e inherit pro_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a47a3020ab06d49b995e22c7b4567017e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a47a3020ab06d49b995e22c7b4567017e">mHasStarted</a></td></tr>
<tr class="memdesc:a47a3020ab06d49b995e22c7b4567017e inherit pro_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">mHasStarted bool that tracks whether or not the <a class="el" href="class_comm_type.html#a78d309086195c52051f007e693ff2b7a" title="startup Each comm type has a series of threads that maintain the connection and check for changes...">startup()</a> routine has been called. Gets set to false after the <a class="el" href="class_comm_type.html#ad2a24398eeaafa49cd376cb09be961ef" title="shutdown turns off all threads that maintain the connection and check for changes. Also shuts down any discovery threads, if they are currently running. ">shutdown()</a> routine is callsed. <br /></td></tr>
<tr class="separator:a47a3020ab06d49b995e22c7b4567017e inherit pro_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_class_comm_type"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_class_comm_type')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="class_comm_type.html">CommType</a></td></tr>
<tr class="memitem:a932133199df9b51ff3a368009e1b6d53 inherit pro_static_attribs_class_comm_type"><td class="memItemLeft" align="right" valign="top"><a id="a932133199df9b51ff3a368009e1b6d53"></a>
static const QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a932133199df9b51ff3a368009e1b6d53">kDiscoveryPacketIdentifier</a> = &quot;DISCOVERY_PACKET&quot;</td></tr>
<tr class="memdesc:a932133199df9b51ff3a368009e1b6d53 inherit pro_static_attribs_class_comm_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">string at the beginning of each discovery packet. <br /></td></tr>
<tr class="separator:a932133199df9b51ff3a368009e1b6d53 inherit pro_static_attribs_class_comm_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2017. Released under the GNU General Public License.</dd></dl>
<pre class="fragment">   It uses a HueBridgeDiscovery object to store data about the Hue Bridge
   and to run discovery methods if none is currently connected. Once a connection
   is established, it uses its mStateUpdateTimer to poll for updates from the Bridge
   about the current lights. This object also acts as a layer that takes the protocols from
   the rest of the application, and converts it to packets that the Bridge can understand.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6437a21abfd54172305bd1eda8c52845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6437a21abfd54172305bd1eda8c52845">&#9670;&nbsp;</a></span>CommHue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CommHue::CommHue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2017. Released under the GNU General Public License. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3e1b2d69fc4a3e4b4a56e8a712cf794f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1b2d69fc4a3e4b4a56e8a712cf794f">&#9670;&nbsp;</a></span>bridge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_hue_bridge.html">SHueBridge</a> CommHue::bridge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>struct that represents the bridge. </dd></dl>

</div>
</div>
<a id="acbdf6a9d59c217d618301b2a0ba40327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbdf6a9d59c217d618301b2a0ba40327">&#9670;&nbsp;</a></span>brightnessChange</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::brightnessChange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deviceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>brightness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceIndex</td><td>0 for all indices, a specific index for a specific light. Will do nothing if index doesn't exist. </td></tr>
    <tr><td class="paramname">brightness</td><td>a value between 0 and 100, 0 is off, 100 is full brightness </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3bd2ad9af191059d11ab1a7dc36efd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bd2ad9af191059d11ab1a7dc36efd9">&#9670;&nbsp;</a></span>changeColorCT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::changeColorCT </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lightIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>brightness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>index of light that you want to change the color temperature of. </td></tr>
    <tr><td class="paramname">brightness</td><td>brightness between 0 and 100, with 100 being full brightness. </td></tr>
    <tr><td class="paramname">ct</td><td>a new value for the color temperature, given in meriks. Must be between 153 and 500. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39706ac1161e2b4787f9e29848953fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39706ac1161e2b4787f9e29848953fa1">&#9670;&nbsp;</a></span>changeColorRGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::changeColorRGB </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lightIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>saturation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>brightness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>the index of the hue being changed. </td></tr>
    <tr><td class="paramname">saturation</td><td>how saturated the color is. A higher number leads to more saturation. Must be in the range of 0 and 254, inclusive. </td></tr>
    <tr><td class="paramname">brightness</td><td>how bright the light will be. A higher number leads to more brightness. Must be in the range of 0 and 254, inclusive. </td></tr>
    <tr><td class="paramname">hue</td><td>the hue of the hue light's color. Must be in the range of 0 and 65535, with 0 representing pure red. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57ff41ac21bb508ba33f0402e5ab57b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ff41ac21bb508ba33f0402e5ab57b5">&#9670;&nbsp;</a></span>connectedHues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="struct_s_hue_light.html">SHueLight</a>&gt; CommHue::connectedHues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a vector of the currently connected hue lights. </dd></dl>

</div>
</div>
<a id="ad3c1cee118ea718bf532fad597aeb40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c1cee118ea718bf532fad597aeb40d">&#9670;&nbsp;</a></span>createGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::createGroup </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="struct_s_hue_light.html">SHueLight</a> &gt;&#160;</td>
          <td class="paramname"><em>lights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the new name for the bridge </td></tr>
    <tr><td class="paramname">lights</td><td>the lights to include in the new group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b0fbc05c68eae8656ccf9ae2a2d1753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0fbc05c68eae8656ccf9ae2a2d1753">&#9670;&nbsp;</a></span>createIdleTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::createIdleTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minutes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index of the light in the Hue Bridge. </td></tr>
    <tr><td class="paramname">minutes</td><td>the amount of minutes it takes for a light to idle off. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a099b9b4c0fa13a28de49858c4043afbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099b9b4c0fa13a28de49858c4043afbc">&#9670;&nbsp;</a></span>createSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::createSchedule </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_hue_command.html">SHueCommand</a>&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>localtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the schedule </td></tr>
    <tr><td class="paramname">description</td><td>a description of the scheedule </td></tr>
    <tr><td class="paramname">command</td><td>the command to do when the schedule should execute </td></tr>
    <tr><td class="paramname">localtime</td><td>the localtime of the schedule. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc33dc2377b1f5c653fa93c641272a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc33dc2377b1f5c653fa93c641272a94">&#9670;&nbsp;</a></span>deleteGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::deleteGroup </td>
          <td>(</td>
          <td class="paramtype">SHueGroup&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group to delete from the bridge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a602fc8ae2373378eaf1d528577d5d8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602fc8ae2373378eaf1d528577d5d8cd">&#9670;&nbsp;</a></span>deleteLight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::deleteLight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_hue_light.html">SHueLight</a>&#160;</td>
          <td class="paramname"><em>light</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light</td><td>the light to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de7a0ee906a9ecf1f4dd32208ecdea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de7a0ee906a9ecf1f4dd32208ecdea7">&#9670;&nbsp;</a></span>deleteSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::deleteSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_hue_schedule.html">SHueSchedule</a>&#160;</td>
          <td class="paramname"><em>schedule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schedule</td><td>the schedule to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae88f3e48667d971fcfb337a06fce28b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88f3e48667d971fcfb337a06fce28b7">&#9670;&nbsp;</a></span>discovery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_hue_bridge_discovery.html">HueBridgeDiscovery</a>* CommHue::discovery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the discovery object for finding the Hue Bridge. </dd></dl>

</div>
</div>
<a id="a84dfaf04e9d6f01b3bee479cf0a6d3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dfaf04e9d6f01b3bee479cf0a6d3e3">&#9670;&nbsp;</a></span>hueLightFromLightDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_hue_light.html">SHueLight</a> CommHue::hueLightFromLightDevice </td>
          <td>(</td>
          <td class="paramtype">const SLightDevice &amp;&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a SLightDevice that represents the <a class="el" href="struct_s_hue_light.html" title="The SHueLight struct a struct that stores all the relevant data received from a state update from the...">SHueLight</a> you want to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="struct_s_hue_light.html" title="The SHueLight struct a struct that stores all the relevant data received from a state update from the...">SHueLight</a> that represents the same device as the SLightDevice given. </dd></dl>

</div>
</div>
<a id="ae090b9b2f2ab6d3e47c45d91433c6895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae090b9b2f2ab6d3e47c45d91433c6895">&#9670;&nbsp;</a></span>lightDeviceFromHueLight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SLightDevice CommHue::lightDeviceFromHueLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_hue_light.html">SHueLight</a> &amp;&#160;</td>
          <td class="paramname"><em>light</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light</td><td>the <a class="el" href="struct_s_hue_light.html" title="The SHueLight struct a struct that stores all the relevant data received from a state update from the...">SHueLight</a> representation that you want to convert intoa SLightDevice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SLightDevice if one with data exists, otherwise an empty SLightDevice </dd></dl>

</div>
</div>
<a id="a3b6073064325473abf0459a3cdea3bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6073064325473abf0459a3cdea3bde">&#9670;&nbsp;</a></span>postJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::postJson </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>resource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QJsonObject&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td>the resource that you want to control with the hue bridge. This may be a group, light, or schedule. </td></tr>
    <tr><td class="paramname">object</td><td>the JSON object that you want to give to the resource. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5401aeb2a77f24454d55d4a2914ad488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5401aeb2a77f24454d55d4a2914ad488">&#9670;&nbsp;</a></span>putJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::putJson </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>resource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QJsonObject&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td>the resource that you want to control with the hue bridge. This may be a group, light, or schedule. </td></tr>
    <tr><td class="paramname">object</td><td>the JSON object that you want to give to the resource. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ebc296975e29ab154eebbff9054c58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebc296975e29ab154eebbff9054c58a">&#9670;&nbsp;</a></span>renameLight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::renameLight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_hue_light.html">SHueLight</a>&#160;</td>
          <td class="paramname"><em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light</td><td>the light to rename </td></tr>
    <tr><td class="paramname">newName</td><td>the new name to assign to it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b39a6fa768af92c308428a2f597e649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b39a6fa768af92c308428a2f597e649">&#9670;&nbsp;</a></span>schedules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="struct_s_hue_schedule.html">SHueSchedule</a>&gt; CommHue::schedules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>list of all known schedules. </dd></dl>

</div>
</div>
<a id="a95720c743b01d411710d7a500c2042b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95720c743b01d411710d7a500c2042b2">&#9670;&nbsp;</a></span>searchForNewLights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::searchForNewLights </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; QString &gt;&#160;</td>
          <td class="paramname"><em>serialNumbers</em> = <code>std::list&lt;QString&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialNumbers</td><td>serial numbers to search for manually. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0ea74e3a990f775cf9c9f5188370c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ea74e3a990f775cf9c9f5188370c49">&#9670;&nbsp;</a></span>sendPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_device_controller.html">SDeviceController</a>&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the comma delimited Corlum Light command. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_comm_type.html#a937222fbbe69a6485a18fe2ba1d58a5f">CommType</a>.</p>

</div>
</div>
<a id="a8b80833f0f35e62ea27427c139379fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b80833f0f35e62ea27427c139379fa7">&#9670;&nbsp;</a></span>sendSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::sendSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_hue_schedule.html">SHueSchedule</a>&#160;</td>
          <td class="paramname"><em>schedule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schedule</td><td>the new schedule for the bridge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc2197131a6b7dabef3b406bee54ab64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2197131a6b7dabef3b406bee54ab64">&#9670;&nbsp;</a></span>SHueCommandToJsonObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QJsonObject CommHue::SHueCommandToJsonObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_hue_command.html">SHueCommand</a>&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>the command to convert into json </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a json representation of a command </dd></dl>

</div>
</div>
<a id="a4da488093965bb26bb79b4b98a92ba66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da488093965bb26bb79b4b98a92ba66">&#9670;&nbsp;</a></span>SLightDeviceToJsonObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QJsonObject CommHue::SLightDeviceToJsonObject </td>
          <td>(</td>
          <td class="paramtype">SLightDevice&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>the device to turn into a json object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a json representation of the SLightDevice. </dd></dl>

</div>
</div>
<a id="a14a5ac47af072e9573f4349552de3b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a5ac47af072e9573f4349552de3b8a">&#9670;&nbsp;</a></span>turnOff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::turnOff </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lightIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>the index of the hue you want to turn off. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7e58e5e30432d41ec5db8629aa96003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e58e5e30432d41ec5db8629aa96003">&#9670;&nbsp;</a></span>turnOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::turnOn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lightIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>the index of the hue you want to turn on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bd20cb0e9daca2452b441f57a442771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd20cb0e9daca2452b441f57a442771">&#9670;&nbsp;</a></span>updateGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::updateGroup </td>
          <td>(</td>
          <td class="paramtype">SHueGroup&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="struct_s_hue_light.html">SHueLight</a> &gt;&#160;</td>
          <td class="paramname"><em>lights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group to change the lights in </td></tr>
    <tr><td class="paramname">lights</td><td>the new lights to provide to the group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7fed02de7e4c501b076860a18ac0eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fed02de7e4c501b076860a18ac0eba">&#9670;&nbsp;</a></span>updateIdleTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::updateIdleTimeout </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scheduleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minutes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true to turn on the idle timeout, false to turn it off. </td></tr>
    <tr><td class="paramname">scheduleID</td><td>The ID of the schedule that you want to turn on and off. This ID does not necessarily map to the resource or group ID. </td></tr>
    <tr><td class="paramname">minutes</td><td>the number of minutes it should take to timeout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76bceccaa3425c88f9f971a74423d4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bceccaa3425c88f9f971a74423d4dd">&#9670;&nbsp;</a></span>updateSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommHue::updateSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_hue_schedule.html">SHueSchedule</a>&#160;</td>
          <td class="paramname"><em>schedule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_hue_schedule.html">SHueSchedule</a>&#160;</td>
          <td class="paramname"><em>newSchedule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schedule</td><td>the schedule to update </td></tr>
    <tr><td class="paramname">newSchedule</td><td>the new information to provide to the scheudle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="commhue_8h_source.html">commhue.h</a></li>
<li>commhue.cpp</li>
</ul>
</div><!-- contents -->

<hr>
<table style="width:100%">
  <tr>
    <td>
      <p align="left">
      <small>
          &nbsp; &nbsp; LightingGUI Copyright 2015 - 2017  &nbsp; &nbsp; <br>
          &nbsp; &nbsp; All Rights MIT Licensed.  &nbsp; &nbsp; 
       </small>
       </p>
    </td>
    <td>
      <p align="right">
      <small>
          &nbsp; &nbsp;  Generated by doxygen 1.8.11  &nbsp; &nbsp;
       </small>
       </p>
    </td>
  </tr>
</table>
