<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Corluma: Backend Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CSS_Corluma.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Corluma
   &#160;<span id="projectnumber">v0.19.75</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Backend Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>An overview of the backend classes in Corluma.</p>
<div class="backendOverview"></div><div class="backendOverview">The backend handles communicating with the lights, storing data about the session, and generating the icons for the GUI.</div><div class="backendOverview"><h1>Core Objects</h1>
</div><div class="backendOverview"></div><div class="backendOverview"></div><h1><a class="anchor" id="sec_1"></a>
cor::LightState</h1>
<div class="backendOverview"> The LightState class stores the state of a light during display or a mood. A LightState is whether or not a light is on, what color its showing, etc. LightStates are standardized across all light types, so a Hue will accept the same state as a Nanoleaf. However, not all lights support all types of states. For instance, a hue can't support multiple colors simultaneously. It is up to the dowwnstream systems to handle checks and verify that the light state they are given makes sense with the light they are controlling. <dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
</div><h1><a class="anchor" id="sec_2"></a>
cor::Light</h1>
<div class="backendOverview"> The Light class is the base datatype used for working with lights in Corluma. At a minimum, it contains a unique ID for referencing the light, a <a class="el" href="class_comm_type.html" title="inherited by comm types, provides a general interface that can be used to do connections and sending ...">CommType</a> for the communication used to talk to the light, and a LightState to define the state of the light (IE, is it on, what color is it). The Light object is a bit heavy and when possible, its better to think in LightStates and allow a LightList to assign a state to multiple lights. <dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
Most light protocols also have their own derived class of light, which contains all light information, plus some additional metadata about that type of hardware that is unique to that hardware. For example, some hardware comes with API versions, but not all do, so theres no way to query an API version of a standard Light object.</div><div class="backendOverview"></div><h1><a class="anchor" id="sec_3"></a>
cor::Palette</h1>
<div class="backendOverview"> The Palette class defines a name, a vector of colors, and an enum. Each palette maintains a JSON representation and a standard representation of all of its data. The enum will be defined as "custom" if it doesn't match a known palette for Corluma. <dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
</div><h1><a class="anchor" id="sec_4"></a>
cor::Group</h1>
<div class="backendOverview"> The Group class is a lightweight class for storing information about a group of lights. A group has its own name and unique ID, and it always contains a list of unique IDs of lights. <dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
</div><h1><a class="anchor" id="sec_5"></a>
cor::Mood</h1>
<div class="backendOverview"> The Mood class is a recipe for creating a group of lights with predefined states. A mood has a unique ID, a name, and a list of states of lights. A mood can also have default states for entire groups, as well as additional information about the mood. Default states are used as a fallback. If a light already has information in the mood, <em>and</em> its covered by a default state, the state prefers the info on the light over the default state. <dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
<h1>Group Data</h1>
</div><div class="backendOverview"></div><div class="backendOverview"></div><h1><a class="anchor" id="sec_6"></a>
GroupData</h1>
<div class="backendOverview"> The <a class="el" href="class_group_data.html" title="The GroupData class manipulates and reads a JSON representation of multiple lights. This data can be exported or overriden from the SettingsPage. The data stored here is only the data that can&#39;t be stored externally. For example, Hue Bridges support groups and rooms, so all hue related data is stored on the bridge. Moods are not easily supported, so hue&#39;s are stored in moods. Arduinos support none of these features, so all data for arduinos are stored locally. ">GroupData</a> class manipulates and reads a JSON representation of multiple lights. This data can be exported or overriden from the <a class="el" href="class_settings_page.html" title="The SettingsPage provides a way to configure the application settings and view copyright information...">SettingsPage</a>. The data stored here is only the data that can't be stored externally. For example, Hue Bridges support groups and rooms, so all hue related data is stored on the bridge. Moods are not easily supported, so hue's are stored in moods. Arduinos support none of these features, so all data for arduinos are stored locally. <dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
There exists three ways to group lights. The first is a "room". Each light can only belong to one room, and the state of the light is not important (which is to say, whether a light is on or off, its still part of a room." The next group is more generic, and has the more generic name "group." A group is simply any predefined set of lights, without state data. For instance, 3 lights that are all part of the same lighting fixture can be made into a group. Technically speaking, all rooms are special cases of groups. The final type of group is a "mood." Moods are more complex, and they store not only unique lights, but also their states. Moods can also have "default
states" for groups and rooms. If a light is part of a group or room with a default state and is not specifically marked as part of a mood, the light will inherit the default state.</div><div class="backendOverview"></div><h1><a class="anchor" id="sec_7"></a>
SubgroupData</h1>
<div class="backendOverview"> The <a class="el" href="class_subgroup_data.html" title="The SubgroupData class stores the relationship between groups. Group A is a subgroup of Group B if al...">SubgroupData</a> class stores the relationship between groups. Group A is a subgroup of Group B if all lights within A are also within B. It contains an unordered_map which utilizes group IDs as keys, and for its values is a vector of associated subgroups.</div><div class="backendOverview"></div><h1><a class="anchor" id="sec_8"></a>
ParentData</h1>
<div class="backendOverview"> The <a class="el" href="class_parent_data.html" title="The ParentData class stores a vector of parent groups. A &quot;parent group&quot; is defined as either being a ...">ParentData</a> class stores a vector of parent groups. A "parent group" is defined as either being a room, or having no group that encompasses all the lights in the group. For example, a bedroom is a room, so its a parent. Also, a group that contains all lights on the first floor across all rooms is a parent group if theres no group that contains all the first floor lights <em>and</em> all the second floor lights. However, if theres a group of lights for a desk in a bedroom, then it is not a parent group, since the bedroom encompasses all the lights for the desk as well.</div><div class="backendOverview"></div><h1><a class="anchor" id="sec_9"></a>
OrphanData</h1>
<div class="backendOverview"> The <a class="el" href="class_orphan_data.html" title="The OrphanData class stores all the lights that don&#39;t belong to any group or room. These lights are treated as &quot;orphans&quot; and a group with a unique ID of &quot;0&quot; stores them. The OrphanGroup is named &quot;Miscellaneous&quot;. ">OrphanData</a> class stores all the lights that don't belong to any group or room. These lights are treated as "orphans" and a group with a unique ID of "0" stores them. The OrphanGroup is named "Miscellaneous".</div><div class="backendOverview"><h1>Main Backend Classes</h1>
</div><div class="backendOverview"></div><div class="backendOverview"></div><h1><a class="anchor" id="sec_10"></a>
CommLayer</h1>
<div class="backendOverview"> The <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> class provides communication protocols that allow the user to connect and send packets to a light. Each light protocol type has its own class for maintaining communciation with lights of that type, and all of those classes are wrapped by <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> and given a standardized API. Each protocol also has its own discovery class, which handles <em>just</em> discovery of the lights, and storage of that discovery data. <dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
<a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> is important in generalizing the divergent APIs of lights. Even though some lights may use RGB, some may use HSV, and some may not even support colors, <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> gives them all the same high level API, and allows the developer to access more specific fucntions, if necessary.</div><div class="backendOverview"><a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> also stores the state of the lights, based off of packets it receives. Each light can be queryed by either a <a class="el" href="classcor_1_1_light.html" title="The Light class is the base datatype used for working with lights in Corluma. At a minimum...">cor::Light</a> object or its unique ID. When a user decides to change the state of the light, the <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a>'s stored state is queryed and packets keep getting sent until the <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a>'s state matches the user's desired state.</div><div class="backendOverview">A UPnP discovery object is also wrapped by <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a>, which is used to discover lights that give their discovery information over UPnP. Since UPnP requires binding to a socket, all discovery objects share the same <a class="el" href="class_u_pn_p_discovery.html" title="The UPnPDiscovery class listens for UPnP packets and signals them out when they are received...">UPnPDiscovery</a> object, and subscribe/unsubscribe to listening to it.</div><div class="backendOverview"></div><h1><a class="anchor" id="sec_11"></a>
cor::LightList</h1>
<div class="backendOverview"> The LightList class stores and maintains a list of lights and their desired states. This object is used for storing what the user <em>wants</em> the lights to be. It also has some helper functions that generalize the state of lights. For instance, theres a brightness function that looks at the brightness of all lights in the list and returns an average. <dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
</div><h1><a class="anchor" id="sec_12"></a>
DataSync</h1>
<div class="backendOverview"> The <a class="el" href="class_data_sync.html" title="The DataSync base class is used for datasync threads. These threads compares the LightList&#39;s represen...">DataSync</a> base class is used for datasync threads. These threads compares the LightList's representation of lights with the <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a>'s understanding of lights and tries to sync them up. The LightList's representation is used as the "desired" state of lights. The <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a>'s understanding is used as the current state. If the desired state and current state do not match, the ComMLayer is requested to send packets to try to update the devices. Different datasync threads run at different speeds and have different criteria for how to handle syncing. Philips hue lights, for instance, require syncing of schedules and groups on top of standard information. Because of this, derived classes impelement the different rules for handling syncing data.</div><div class="backendOverview"></div><h1><a class="anchor" id="sec_13"></a>
cor::StateObserver</h1>
<div class="backendOverview"> The StateObserver class listens to state changes in any of the main widgets of the application, and computes the intended state for the selected lights. It then triggers any updates that are required for the app. This includes both UI updates and packets that need to be sent to light hardware. The observer is set up from the <a class="el" href="class_main_window.html" title="The MainWindow class is the only window in this application. It contains a QStackedWidget which shows...">MainWindow</a> and acts as a sorta arbitrator for all user actions. <dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
This class exists to simplify app design. Before its existence, if the user wanted to select a color from the <a class="el" href="class_color_page.html" title="The ColorPage provides a way to change the color of the lights selected in the app. ">ColorPage</a>, they also needed to query the <a class="el" href="class_routine_buttons_widget.html" title="The RoutineButtonsWidget class is a basic widget that holds a grid of lightsbuttons that each map to ...">RoutineButtonsWidget</a> to check what routine to use, and in some cases, the <a class="el" href="class_global_brightness_widget.html" title="The GlobalBrightnessWidget is a widget that controls the brightness of all selected lights...">GlobalBrightnessWidget</a> to check how bright the lights should be. This class allows widgets to have less relationships with each other, and instead, theres one class that pays attention to everyone and resolves the complex relationships.</div><div class="backendOverview"></div><h1><a class="anchor" id="sec_14"></a>
IconData</h1>
<div class="backendOverview"> The <a class="el" href="class_icon_data.html" title="The IconData class creates all the pixel-y square icons that are seen throughout the app...">IconData</a> class creates all the pixel-y square icons that are seen throughout the app. The grids are made by using a very small buffer of RGB values to do the computation. <dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
</div> </div></div><!-- contents -->

<hr>
<table style="width:100%">
  <tr>
    <td>
      <p align="left">
      <small>
          &nbsp; &nbsp; Corluma Copyright 2015 - 2020  &nbsp; &nbsp; <br>
          &nbsp; &nbsp; All Rights GPL v3.0 Licensed.  &nbsp; &nbsp;
       </small>
       </p>
    </td>
    <td>
      <p align="right">
      <small>
          &nbsp; &nbsp;  Generated by doxygen &nbsp; &nbsp;
       </small>
       </p>
    </td>
  </tr>
</table>
