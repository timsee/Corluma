<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Corluma: CommLayer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CSS_Corluma.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Corluma
   &#160;<span id="projectnumber">v0.21.86</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_comm_layer-members.html">List of all members</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">CommLayer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> class provides communication protocols that allow the user to connect and send packets to a light. Each light protocol type has its own class for maintaining communciation with lights of that type, and all of those classes are wrapped by <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> and given a standardized API. Each protocol also has its own discovery class, which handles <em>just</em> discovery of the lights, and storage of that discovery data.  
 <a href="class_comm_layer.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="commlayer_8h_source.html">commlayer.h</a>&quot;</code></p>

<p>Inherits QObject.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:a123e00f7e95da05ae136dd3204da834c"><td class="memItemLeft" align="right" valign="top"><a id="a123e00f7e95da05ae136dd3204da834c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a123e00f7e95da05ae136dd3204da834c">packetReceived</a> (EProtocolType)</td></tr>
<tr class="memdesc:a123e00f7e95da05ae136dd3204da834c"><td class="mdescLeft">&#160;</td><td class="mdescRight">packetReceived anotification that a packet was receieved by one of the commtypes. <br /></td></tr>
<tr class="separator:a123e00f7e95da05ae136dd3204da834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c7b37bf51d4e8592d0eba768a39655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a92c7b37bf51d4e8592d0eba768a39655">updateReceived</a> (ECommType)</td></tr>
<tr class="memdesc:a92c7b37bf51d4e8592d0eba768a39655"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateReceived a notification that a packet was received by one of the commtypes.  <a href="class_comm_layer.html#a92c7b37bf51d4e8592d0eba768a39655">More...</a><br /></td></tr>
<tr class="separator:a92c7b37bf51d4e8592d0eba768a39655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ce7290a73060e3bda9ff4c74ce811"><td class="memItemLeft" align="right" valign="top"><a id="ae51ce7290a73060e3bda9ff4c74ce811"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#ae51ce7290a73060e3bda9ff4c74ce811">lightsAdded</a> (std::vector&lt; QString &gt;)</td></tr>
<tr class="memdesc:ae51ce7290a73060e3bda9ff4c74ce811"><td class="mdescLeft">&#160;</td><td class="mdescRight">emits when one or more lights are added from the commlayer <br /></td></tr>
<tr class="separator:ae51ce7290a73060e3bda9ff4c74ce811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac648dd31161758b0aa35f6cbc8fc7c1c"><td class="memItemLeft" align="right" valign="top"><a id="ac648dd31161758b0aa35f6cbc8fc7c1c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#ac648dd31161758b0aa35f6cbc8fc7c1c">lightsDeleted</a> (std::vector&lt; QString &gt;)</td></tr>
<tr class="memdesc:ac648dd31161758b0aa35f6cbc8fc7c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">emits when one or more lights delete from the commlayer <br /></td></tr>
<tr class="separator:ac648dd31161758b0aa35f6cbc8fc7c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79560fef165cc4b6ba98c7a140a5cc07"><td class="memItemLeft" align="right" valign="top"><a id="a79560fef165cc4b6ba98c7a140a5cc07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a79560fef165cc4b6ba98c7a140a5cc07">lightNameChanged</a> (QString, QString)</td></tr>
<tr class="memdesc:a79560fef165cc4b6ba98c7a140a5cc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">emits when a light changes its name <br /></td></tr>
<tr class="separator:a79560fef165cc4b6ba98c7a140a5cc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a29a8645f0564865941cb050f980bb1e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a29a8645f0564865941cb050f980bb1e5">CommLayer</a> (QObject *parent, <a class="el" href="class_group_data.html">GroupData</a> *groups)</td></tr>
<tr class="memdesc:a29a8645f0564865941cb050f980bb1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_comm_layer.html#a29a8645f0564865941cb050f980bb1e5">More...</a><br /></td></tr>
<tr class="separator:a29a8645f0564865941cb050f980bb1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a70a6c68dd4de56ad6c999e66ad4bff"><td class="memItemLeft" align="right" valign="top"><a id="a5a70a6c68dd4de56ad6c999e66ad4bff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a5a70a6c68dd4de56ad6c999e66ad4bff">resetStateUpdates</a> (EProtocolType type)</td></tr>
<tr class="memdesc:a5a70a6c68dd4de56ad6c999e66ad4bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">resetStateUpdates reset the state updates timeouts for specified commtypes. If it isn't on already, it gets turned on. <br /></td></tr>
<tr class="separator:a5a70a6c68dd4de56ad6c999e66ad4bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1137c14c4f7dedb8b5b3e36eb0324bb2"><td class="memItemLeft" align="right" valign="top"><a id="a1137c14c4f7dedb8b5b3e36eb0324bb2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a1137c14c4f7dedb8b5b3e36eb0324bb2">isActive</a> (EProtocolType type)</td></tr>
<tr class="memdesc:a1137c14c4f7dedb8b5b3e36eb0324bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the protocol is receiving state updates, false otherwise. <br /></td></tr>
<tr class="separator:a1137c14c4f7dedb8b5b3e36eb0324bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbf4b32b9137e7015f5b7c14c1ae784"><td class="memItemLeft" align="right" valign="top"><a id="adfbf4b32b9137e7015f5b7c14c1ae784"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#adfbf4b32b9137e7015f5b7c14c1ae784">stopStateUpdates</a> (EProtocolType type)</td></tr>
<tr class="memdesc:adfbf4b32b9137e7015f5b7c14c1ae784"><td class="mdescLeft">&#160;</td><td class="mdescRight">stopStateUpdates turn off the state update threads for specified commtypes. <br /></td></tr>
<tr class="separator:adfbf4b32b9137e7015f5b7c14c1ae784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47f0c2e4f391d0af4c848aa975f1c56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#ab47f0c2e4f391d0af4c848aa975f1c56">startup</a> (EProtocolType type)</td></tr>
<tr class="memdesc:ab47f0c2e4f391d0af4c848aa975f1c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">startup start stream of given type. This starts all of its maintence threads and discovery threads  <a href="class_comm_layer.html#ab47f0c2e4f391d0af4c848aa975f1c56">More...</a><br /></td></tr>
<tr class="separator:ab47f0c2e4f391d0af4c848aa975f1c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee121cc6b33f7963382d83180661f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#aeee121cc6b33f7963382d83180661f4f">shutdown</a> (EProtocolType type)</td></tr>
<tr class="memdesc:aeee121cc6b33f7963382d83180661f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">shutdown shuts down the stream of the given type. This stops all of its maintence threads and discovery threads.  <a href="class_comm_layer.html#aeee121cc6b33f7963382d83180661f4f">More...</a><br /></td></tr>
<tr class="separator:aeee121cc6b33f7963382d83180661f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7545cb1601f977d128aad856fa5a3bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a7545cb1601f977d128aad856fa5a3bfa">fillLight</a> (<a class="el" href="classcor_1_1_light.html">cor::Light</a> &amp;light)</td></tr>
<tr class="memdesc:a7545cb1601f977d128aad856fa5a3bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">fillLight use the controller name, type, and index to fill in the rest of the devices data.  <a href="class_comm_layer.html#a7545cb1601f977d128aad856fa5a3bfa">More...</a><br /></td></tr>
<tr class="separator:a7545cb1601f977d128aad856fa5a3bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ab15d3f8c31727bc4f6fed6004dc71"><td class="memItemLeft" align="right" valign="top"><a id="a66ab15d3f8c31727bc4f6fed6004dc71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a66ab15d3f8c31727bc4f6fed6004dc71">startDiscovery</a> (EProtocolType type)</td></tr>
<tr class="memdesc:a66ab15d3f8c31727bc4f6fed6004dc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">startDiscovery put given comm type into discovery mode. <br /></td></tr>
<tr class="separator:a66ab15d3f8c31727bc4f6fed6004dc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbd806e7abcdf340ad2e91d0c113484"><td class="memItemLeft" align="right" valign="top"><a id="a9fbd806e7abcdf340ad2e91d0c113484"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a9fbd806e7abcdf340ad2e91d0c113484">stopDiscovery</a> (EProtocolType type)</td></tr>
<tr class="memdesc:a9fbd806e7abcdf340ad2e91d0c113484"><td class="mdescLeft">&#160;</td><td class="mdescRight">stopDiscovery stop the given comm type's discovery mode. <br /></td></tr>
<tr class="separator:a9fbd806e7abcdf340ad2e91d0c113484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d204c12ecc658add4e4e32b570d8e4"><td class="memItemLeft" align="right" valign="top"><a id="a14d204c12ecc658add4e4e32b570d8e4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a14d204c12ecc658add4e4e32b570d8e4">discoveryErrorsExist</a> (EProtocolType type)</td></tr>
<tr class="memdesc:a14d204c12ecc658add4e4e32b570d8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if theres any known errors for the commtype. <br /></td></tr>
<tr class="separator:a14d204c12ecc658add4e4e32b570d8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c76da127ce0643733b04058d1de0bc"><td class="memItemLeft" align="right" valign="top"><a id="af4c76da127ce0643733b04058d1de0bc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#af4c76da127ce0643733b04058d1de0bc">anyLightsFound</a> ()</td></tr>
<tr class="memdesc:af4c76da127ce0643733b04058d1de0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if any lights are found, false otherwise <br /></td></tr>
<tr class="separator:af4c76da127ce0643733b04058d1de0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd37f6d99781cb303c243446d8a50d70"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcor_1_1_dictionary.html">cor::Dictionary</a>&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#acd37f6d99781cb303c243446d8a50d70">lightDict</a> (ECommType type) const</td></tr>
<tr class="memdesc:acd37f6d99781cb303c243446d8a50d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">deviceTable dictionary of all connected devices of a certain connection type. The light names are used as keys.  <a href="class_comm_layer.html#acd37f6d99781cb303c243446d8a50d70">More...</a><br /></td></tr>
<tr class="separator:acd37f6d99781cb303c243446d8a50d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34ef82ec008e84d9ccaa788e47da645"><td class="memItemLeft" align="right" valign="top"><a id="ae34ef82ec008e84d9ccaa788e47da645"></a>
<a class="el" href="classcor_1_1_light.html">cor::Light</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#ae34ef82ec008e84d9ccaa788e47da645">lightByID</a> (const QString &amp;ID) const</td></tr>
<tr class="memdesc:ae34ef82ec008e84d9ccaa788e47da645"><td class="mdescLeft">&#160;</td><td class="mdescRight">looks up a light by its unique ID and returns its metadata and current state <br /></td></tr>
<tr class="separator:ae34ef82ec008e84d9ccaa788e47da645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fab56332314145ad6688ef69b1e7447"><td class="memItemLeft" align="right" valign="top"><a id="a9fab56332314145ad6688ef69b1e7447"></a>
std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a9fab56332314145ad6688ef69b1e7447">lightsByIDs</a> (const std::vector&lt; QString &gt; IDs) const</td></tr>
<tr class="memdesc:a9fab56332314145ad6688ef69b1e7447"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a vector of unique IDs to a vector cor::Lights <br /></td></tr>
<tr class="separator:a9fab56332314145ad6688ef69b1e7447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7ff47d86dd08aba90e278d1336818b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a0a7ff47d86dd08aba90e278d1336818b">commLightsFromVector</a> (const std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt; &amp;lights)</td></tr>
<tr class="separator:a0a7ff47d86dd08aba90e278d1336818b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fbc9d358708a3a8b82c26ce91cd906"><td class="memItemLeft" align="right" valign="top"><a id="ad5fbc9d358708a3a8b82c26ce91cd906"></a>
std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#ad5fbc9d358708a3a8b82c26ce91cd906">lightListFromGroup</a> (const <a class="el" href="classcor_1_1_group.html">cor::Group</a> &amp;group)</td></tr>
<tr class="memdesc:ad5fbc9d358708a3a8b82c26ce91cd906"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a list of lights and their current state based off of a group. <br /></td></tr>
<tr class="separator:ad5fbc9d358708a3a8b82c26ce91cd906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e02b5e93efb2e42d7c91e97eadd51c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a83e02b5e93efb2e42d7c91e97eadd51c">saveNewGroup</a> (const <a class="el" href="classcor_1_1_group.html">cor::Group</a> &amp;group)</td></tr>
<tr class="memdesc:a83e02b5e93efb2e42d7c91e97eadd51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">saves a for future use. For lights like hues, that can save groups to their bridge, the group is saved externally. For lights without this capability, the Group is saved to the <a class="el" href="class_group_data.html">GroupData</a> provided to the constructor.  <a href="class_comm_layer.html#a83e02b5e93efb2e42d7c91e97eadd51c">More...</a><br /></td></tr>
<tr class="separator:a83e02b5e93efb2e42d7c91e97eadd51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b634c8b9c7aa6efd5ee99c70e67099"><td class="memItemLeft" align="right" valign="top"><a id="a73b634c8b9c7aa6efd5ee99c70e67099"></a>
<a class="el" href="classcor_1_1_dictionary.html">cor::Dictionary</a>&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a73b634c8b9c7aa6efd5ee99c70e67099">makeMood</a> (const <a class="el" href="classcor_1_1_mood.html">cor::Mood</a> &amp;mood)</td></tr>
<tr class="memdesc:a73b634c8b9c7aa6efd5ee99c70e67099"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes a dictionary of lights based off of the formula provided by a mood object. <br /></td></tr>
<tr class="separator:a73b634c8b9c7aa6efd5ee99c70e67099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9347a5ca4d1e01cdfc221ac6059bdb"><td class="memItemLeft" align="right" valign="top"><a id="a5e9347a5ca4d1e01cdfc221ac6059bdb"></a>
std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a5e9347a5ca4d1e01cdfc221ac6059bdb">allLights</a> ()</td></tr>
<tr class="memdesc:a5e9347a5ca4d1e01cdfc221ac6059bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of all devices from all comm types <br /></td></tr>
<tr class="separator:a5e9347a5ca4d1e01cdfc221ac6059bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5679fea2aaf91ab1291c20963ca4c1"><td class="memItemLeft" align="right" valign="top"><a id="a9a5679fea2aaf91ab1291c20963ca4c1"></a>
const std::vector&lt; <a class="el" href="classcor_1_1_controller.html">cor::Controller</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a9a5679fea2aaf91ab1291c20963ca4c1">allArduinoControllers</a> ()</td></tr>
<tr class="memdesc:a9a5679fea2aaf91ab1291c20963ca4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">list containing all arduino based cor::Controllers <br /></td></tr>
<tr class="separator:a9a5679fea2aaf91ab1291c20963ca4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428a1ea8d5fd6032cb59a421ed30adf3"><td class="memItemLeft" align="right" valign="top"><a id="a428a1ea8d5fd6032cb59a421ed30adf3"></a>
<a class="el" href="class_comm_nanoleaf.html">CommNanoleaf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a428a1ea8d5fd6032cb59a421ed30adf3">nanoleaf</a> ()</td></tr>
<tr class="memdesc:a428a1ea8d5fd6032cb59a421ed30adf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for nanoleaf <br /></td></tr>
<tr class="separator:a428a1ea8d5fd6032cb59a421ed30adf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bc4ce9125b83923af18b3b5dcb6610"><td class="memItemLeft" align="right" valign="top"><a id="a63bc4ce9125b83923af18b3b5dcb6610"></a>
<a class="el" href="class_comm_ardu_cor.html">CommArduCor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a63bc4ce9125b83923af18b3b5dcb6610">arducor</a> ()</td></tr>
<tr class="memdesc:a63bc4ce9125b83923af18b3b5dcb6610"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for arducor <br /></td></tr>
<tr class="separator:a63bc4ce9125b83923af18b3b5dcb6610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccec8a4cd11d52689b73edec6e002fb"><td class="memItemLeft" align="right" valign="top"><a id="a9ccec8a4cd11d52689b73edec6e002fb"></a>
<a class="el" href="class_comm_hue.html">CommHue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a9ccec8a4cd11d52689b73edec6e002fb">hue</a> ()</td></tr>
<tr class="memdesc:a9ccec8a4cd11d52689b73edec6e002fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the hue comm type <br /></td></tr>
<tr class="separator:a9ccec8a4cd11d52689b73edec6e002fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa879caf80e90d279d5817905e6988007"><td class="memItemLeft" align="right" valign="top"><a id="aa879caf80e90d279d5817905e6988007"></a>
std::unordered_set&lt; QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#aa879caf80e90d279d5817905e6988007">allDiscoveredLightIDs</a> ()</td></tr>
<tr class="memdesc:aa879caf80e90d279d5817905e6988007"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a set of all discovered light IDs <br /></td></tr>
<tr class="separator:aa879caf80e90d279d5817905e6988007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4a4450ab9b9d5fe004fb1e89f39415"><td class="memItemLeft" align="right" valign="top"><a id="aed4a4450ab9b9d5fe004fb1e89f39415"></a>
std::unordered_set&lt; QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#aed4a4450ab9b9d5fe004fb1e89f39415">allUndiscoveredLightIDs</a> ()</td></tr>
<tr class="memdesc:aed4a4450ab9b9d5fe004fb1e89f39415"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a set of all undiscovered light IDs <br /></td></tr>
<tr class="separator:aed4a4450ab9b9d5fe004fb1e89f39415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029df785336754203927d2c015ac268d"><td class="memItemLeft" align="right" valign="top"><a id="a029df785336754203927d2c015ac268d"></a>
std::unordered_set&lt; QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a029df785336754203927d2c015ac268d">allLightIDs</a> ()</td></tr>
<tr class="memdesc:a029df785336754203927d2c015ac268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a set of both undiscovered and discovered light IDs <br /></td></tr>
<tr class="separator:a029df785336754203927d2c015ac268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7a621d8e65f81b86e36a0c58e95838"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a8b7a621d8e65f81b86e36a0c58e95838">hueLightsToDevices</a> (std::vector&lt; <a class="el" href="class_hue_metadata.html">HueMetadata</a> &gt; hues)</td></tr>
<tr class="memdesc:a8b7a621d8e65f81b86e36a0c58e95838"><td class="mdescLeft">&#160;</td><td class="mdescRight">hueLightsToDevices helper to convert a list of hue lights into a list of cor::Lights  <a href="class_comm_layer.html#a8b7a621d8e65f81b86e36a0c58e95838">More...</a><br /></td></tr>
<tr class="separator:a8b7a621d8e65f81b86e36a0c58e95838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b262114ae8f64630294e8ed69aed1c"><td class="memItemLeft" align="right" valign="top"><a id="a33b262114ae8f64630294e8ed69aed1c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a33b262114ae8f64630294e8ed69aed1c">deleteHueGroup</a> (const QString &amp;name)</td></tr>
<tr class="memdesc:a33b262114ae8f64630294e8ed69aed1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes a hue group by name <br /></td></tr>
<tr class="separator:a33b262114ae8f64630294e8ed69aed1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b07f1517c34083dc703dcf463eb45e6"><td class="memItemLeft" align="right" valign="top">EColorPickerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a0b07f1517c34083dc703dcf463eb45e6">bestColorPickerType</a> (const std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt; &amp;lights)</td></tr>
<tr class="separator:a0b07f1517c34083dc703dcf463eb45e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fef6e678a6b81e51b51d7c26aa77112"><td class="memItemLeft" align="right" valign="top"><a id="a8fef6e678a6b81e51b51d7c26aa77112"></a>
QTime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a8fef6e678a6b81e51b51d7c26aa77112">lastSendTime</a> ()</td></tr>
<tr class="memdesc:a8fef6e678a6b81e51b51d7c26aa77112"><td class="mdescLeft">&#160;</td><td class="mdescRight">gives the last time any specific <a class="el" href="class_comm_type.html" title="inherited by comm types, provides a general interface that can be used to do connections and sending ...">CommType</a> last sent an update <br /></td></tr>
<tr class="separator:a8fef6e678a6b81e51b51d7c26aa77112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6e3d1bd5cda648191344d21b5f5a04"><td class="memItemLeft" align="right" valign="top"><a id="adf6e3d1bd5cda648191344d21b5f5a04"></a>
QTime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#adf6e3d1bd5cda648191344d21b5f5a04">lastReceiveTime</a> ()</td></tr>
<tr class="memdesc:adf6e3d1bd5cda648191344d21b5f5a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">gives the last time any specific <a class="el" href="class_comm_type.html" title="inherited by comm types, provides a general interface that can be used to do connections and sending ...">CommType</a> last received an update <br /></td></tr>
<tr class="separator:adf6e3d1bd5cda648191344d21b5f5a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5048240dd5b01e95addcad1b0a94e1"><td class="memItemLeft" align="right" valign="top"><a id="afd5048240dd5b01e95addcad1b0a94e1"></a>
<a class="el" href="classcor_1_1_light.html">cor::Light</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#afd5048240dd5b01e95addcad1b0a94e1">addLightMetaData</a> (<a class="el" href="classcor_1_1_light.html">cor::Light</a> light)</td></tr>
<tr class="memdesc:afd5048240dd5b01e95addcad1b0a94e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds meta data to a light, used when creating moods. <br /></td></tr>
<tr class="separator:afd5048240dd5b01e95addcad1b0a94e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85790c5d8639307b67ffd77e6c84661b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcor_1_1_mood.html">cor::Mood</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a85790c5d8639307b67ffd77e6c84661b">addMetadataToMood</a> (const <a class="el" href="classcor_1_1_mood.html">cor::Mood</a> &amp;mood)</td></tr>
<tr class="separator:a85790c5d8639307b67ffd77e6c84661b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4694a569469ad8118607b33e9e279d"><td class="memItemLeft" align="right" valign="top"><a id="acf4694a569469ad8118607b33e9e279d"></a>
std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#acf4694a569469ad8118607b33e9e279d">secondsUntilTimeout</a> (const QString &amp;lights)</td></tr>
<tr class="memdesc:acf4694a569469ad8118607b33e9e279d"><td class="mdescLeft">&#160;</td><td class="mdescRight">seconds until a specific light times out <br /></td></tr>
<tr class="separator:acf4694a569469ad8118607b33e9e279d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c987331541e1a599ad717d7b7af1911"><td class="memItemLeft" align="right" valign="top"><a id="a4c987331541e1a599ad717d7b7af1911"></a>
std::vector&lt; std::uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a4c987331541e1a599ad717d7b7af1911">secondsUntilTimeout</a> (const std::vector&lt; QString &gt; &amp;lights)</td></tr>
<tr class="memdesc:a4c987331541e1a599ad717d7b7af1911"><td class="mdescLeft">&#160;</td><td class="mdescRight">seconds until a group of lights timeout <br /></td></tr>
<tr class="separator:a4c987331541e1a599ad717d7b7af1911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535aee324c29b4cab6209853cae0b735"><td class="memItemLeft" align="right" valign="top"><a id="a535aee324c29b4cab6209853cae0b735"></a>
<a class="el" href="class_u_pn_p_discovery.html">UPnPDiscovery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_layer.html#a535aee324c29b4cab6209853cae0b735">UPnP</a> ()</td></tr>
<tr class="memdesc:a535aee324c29b4cab6209853cae0b735"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for UPnP object <br /></td></tr>
<tr class="separator:a535aee324c29b4cab6209853cae0b735"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License.</dd></dl>
<p><a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> is important in generalizing the divergent APIs of lights. Even though some lights may use RGB, some may use HSV, and some may not even support colors, <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> gives them all the same high level API, and allows the developer to access more specific fucntions, if necessary.</p>
<p><a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> also stores the state of the lights, based off of packets it receives. Each light can be queryed by either a <a class="el" href="classcor_1_1_light.html" title="The Light class is the base datatype used for working with lights in Corluma. At a minimum,...">cor::Light</a> object or its unique ID. When a user decides to change the state of the light, the <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a>'s stored state is queryed and packets keep getting sent until the <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a>'s state matches the user's desired state.</p>
<p>A UPnP discovery object is also wrapped by <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a>, which is used to discover lights that give their discovery information over UPnP. Since UPnP requires binding to a socket, all discovery objects share the same <a class="el" href="class_u_pn_p_discovery.html" title="The UPnPDiscovery class listens for UPnP packets and signals them out when they are received....">UPnPDiscovery</a> object, and subscribe/unsubscribe to listening to it. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a29a8645f0564865941cb050f980bb1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a8645f0564865941cb050f980bb1e5">&#9670;&nbsp;</a></span>CommLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CommLayer::CommLayer </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_group_data.html">GroupData</a> *&#160;</td>
          <td class="paramname"><em>parser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2020. Released under the GNU General Public License. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85790c5d8639307b67ffd77e6c84661b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85790c5d8639307b67ffd77e6c84661b">&#9670;&nbsp;</a></span>addMetadataToMood()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcor_1_1_mood.html">cor::Mood</a> CommLayer::addMetadataToMood </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcor_1_1_mood.html">cor::Mood</a> &amp;&#160;</td>
          <td class="paramname"><em>mood</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fills a mood with its lights metadata, as well as the metadata for its defaults. Pulls from <a class="el" href="class_group_data.html" title="The GroupData class manipulates and reads a JSON representation of multiple lights....">GroupData</a> and <a class="el" href="class_comm_layer.html" title="The CommLayer class provides communication protocols that allow the user to connect and send packets ...">CommLayer</a> when necessary. </p>

</div>
</div>
<a id="a0b07f1517c34083dc703dcf463eb45e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b07f1517c34083dc703dcf463eb45e6">&#9670;&nbsp;</a></span>bestColorPickerType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EColorPickerType CommLayer::bestColorPickerType </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes the best possible color picker type that can be supported based off of the currently selected lights </p>

</div>
</div>
<a id="a0a7ff47d86dd08aba90e278d1336818b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7ff47d86dd08aba90e278d1336818b">&#9670;&nbsp;</a></span>commLightsFromVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt; CommLayer::commLightsFromVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>takes the unique ID's of the lights provided, and returns their state according to comm updates </p>

</div>
</div>
<a id="a7545cb1601f977d128aad856fa5a3bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7545cb1601f977d128aad856fa5a3bfa">&#9670;&nbsp;</a></span>fillLight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommLayer::fillLight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcor_1_1_light.html">cor::Light</a> &amp;&#160;</td>
          <td class="paramname"><em>light</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>the device with a defined name, type, and index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if controller is found and filled, false otherwise. </dd></dl>

</div>
</div>
<a id="a8b7a621d8e65f81b86e36a0c58e95838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7a621d8e65f81b86e36a0c58e95838">&#9670;&nbsp;</a></span>hueLightsToDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcor_1_1_light.html">cor::Light</a> &gt; CommLayer::hueLightsToDevices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_hue_metadata.html">HueMetadata</a> &gt;&#160;</td>
          <td class="paramname"><em>hues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hues</td><td>list of hue lights to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of cor::Lights </dd></dl>

</div>
</div>
<a id="acd37f6d99781cb303c243446d8a50d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd37f6d99781cb303c243446d8a50d70">&#9670;&nbsp;</a></span>lightDict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcor_1_1_dictionary.html">cor::Dictionary</a>&lt;<a class="el" href="classcor_1_1_light.html">cor::Light</a>&gt;&amp; CommLayer::lightDict </td>
          <td>(</td>
          <td class="paramtype">ECommType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the communication type to request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a hash table of all connected devices of the given type. </dd></dl>

</div>
</div>
<a id="a83e02b5e93efb2e42d7c91e97eadd51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e02b5e93efb2e42d7c91e97eadd51c">&#9670;&nbsp;</a></span>saveNewGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommLayer::saveNewGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcor_1_1_group.html">cor::Group</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group to save to external storage or to group data, when applicable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false if encounters error. </dd></dl>

</div>
</div>
<a id="aeee121cc6b33f7963382d83180661f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee121cc6b33f7963382d83180661f4f">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommLayer::shutdown </td>
          <td>(</td>
          <td class="paramtype">EProtocolType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of communication stream to shutdown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab47f0c2e4f391d0af4c848aa975f1c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47f0c2e4f391d0af4c848aa975f1c56">&#9670;&nbsp;</a></span>startup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommLayer::startup </td>
          <td>(</td>
          <td class="paramtype">EProtocolType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of communication stream to start. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92c7b37bf51d4e8592d0eba768a39655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c7b37bf51d4e8592d0eba768a39655">&#9670;&nbsp;</a></span>updateReceived</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommLayer::updateReceived </td>
          <td>(</td>
          <td class="paramtype">ECommType&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the int representation of the ECommType that has been updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="commlayer_8h_source.html">commlayer.h</a></li>
<li>commlayer.cpp</li>
</ul>
</div><!-- contents -->

<hr>
<table style="width:100%">
  <tr>
    <td>
      <p align="left">
      <small>
          &nbsp; &nbsp; Corluma Copyright 2015 - 2021  &nbsp; &nbsp; <br>
          &nbsp; &nbsp; All Rights GPL v3.0 Licensed.  &nbsp; &nbsp;
       </small>
       </p>
    </td>
    <td>
      <p align="right">
      <small>
          &nbsp; &nbsp;  Generated by doxygen &nbsp; &nbsp;
       </small>
       </p>
    </td>
  </tr>
</table>
