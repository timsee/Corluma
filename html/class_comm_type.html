<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Corluma: CommType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CSS_Corluma.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Corluma
   &#160;<span id="projectnumber">v0.9.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_comm_type-members.html">List of all members</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">CommType Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>inherited by comm types, provides a general interface that can be used to do connections and sending packets. Each <a class="el" href="class_comm_type.html" title="inherited by comm types, provides a general interface that can be used to do connections and sending ...">CommType</a> also has its own conenctionList(), which lists up to 5 of the previous connections. This list persists in the application's memory after the application closes.  
 <a href="class_comm_type.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="commtype_8h_source.html">commtype.h</a>&quot;</code></p>

<p>Inherits QWidget.</p>

<p>Inherited by <a class="el" href="class_comm_h_t_t_p.html">CommHTTP</a>, <a class="el" href="class_comm_hue.html">CommHue</a>, <a class="el" href="class_comm_serial.html">CommSerial</a>, and <a class="el" href="class_comm_u_d_p.html">CommUDP</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:a9186f5c260b29ec24d0e1666191afbf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9186f5c260b29ec24d0e1666191afbf6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a9186f5c260b29ec24d0e1666191afbf6">packetReceived</a> (QString, QString, int)</td></tr>
<tr class="memdesc:a9186f5c260b29ec24d0e1666191afbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">packetReceived emitted whenever a packet that is not a discovery packet is received. Contains the full packet's contents as a QString. <br /></td></tr>
<tr class="separator:a9186f5c260b29ec24d0e1666191afbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc434809e1145dff7f9cd3dcd7a068d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbc434809e1145dff7f9cd3dcd7a068d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#acbc434809e1145dff7f9cd3dcd7a068d">discoveryReceived</a> (QString, QString, int)</td></tr>
<tr class="memdesc:acbc434809e1145dff7f9cd3dcd7a068d"><td class="mdescLeft">&#160;</td><td class="mdescRight">discoveryReceived emitted when a discovery packet is received, this contains the state of all connected devices. <br /></td></tr>
<tr class="separator:acbc434809e1145dff7f9cd3dcd7a068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea9af432f13faf2a28b6a9fd5d5000e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea9af432f13faf2a28b6a9fd5d5000e9"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#aea9af432f13faf2a28b6a9fd5d5000e9">~CommType</a> ()</td></tr>
<tr class="memdesc:aea9af432f13faf2a28b6a9fd5d5000e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">~CommType Deconstructor <br /></td></tr>
<tr class="separator:aea9af432f13faf2a28b6a9fd5d5000e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d309086195c52051f007e693ff2b7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78d309086195c52051f007e693ff2b7a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a78d309086195c52051f007e693ff2b7a">startup</a> ()=0</td></tr>
<tr class="memdesc:a78d309086195c52051f007e693ff2b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">startup Each comm type has a series of threads that maintain the connection and check for changes. startup starts all the threads associated with the commtype. If a device has not been discovered, it also starts up a discovery thread. <br /></td></tr>
<tr class="separator:a78d309086195c52051f007e693ff2b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a24398eeaafa49cd376cb09be961ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2a24398eeaafa49cd376cb09be961ef"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ad2a24398eeaafa49cd376cb09be961ef">shutdown</a> ()=0</td></tr>
<tr class="memdesc:ad2a24398eeaafa49cd376cb09be961ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">shutdown turns off all threads that maintain the connection and check for changes. Also shuts down any discovery threads, if they are currently running. <br /></td></tr>
<tr class="separator:ad2a24398eeaafa49cd376cb09be961ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6d7465b678fc3daf1e9580d331c8dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ace6d7465b678fc3daf1e9580d331c8dc">hasStarted</a> ()</td></tr>
<tr class="memdesc:ace6d7465b678fc3daf1e9580d331c8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">hasStarted true if startup has been called and a shutdown has not be called after it, false otherwise.  <a href="#ace6d7465b678fc3daf1e9580d331c8dc">More...</a><br /></td></tr>
<tr class="separator:ace6d7465b678fc3daf1e9580d331c8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6455a9e3aaa20b95077339fa5502ea7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#af6455a9e3aaa20b95077339fa5502ea7">sendPacket</a> (QString controller, QString packet)=0</td></tr>
<tr class="memdesc:af6455a9e3aaa20b95077339fa5502ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">sendPacket Sends the provided string over the connection stream.  <a href="#af6455a9e3aaa20b95077339fa5502ea7">More...</a><br /></td></tr>
<tr class="separator:af6455a9e3aaa20b95077339fa5502ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee085c089155c088acd4ebb4ed41b4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ee085c089155c088acd4ebb4ed41b4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a3ee085c089155c088acd4ebb4ed41b4f">startDiscovery</a> ()</td></tr>
<tr class="memdesc:a3ee085c089155c088acd4ebb4ed41b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">startDiscovery start sending discovery packets if needed, and continually request state update packets. <br /></td></tr>
<tr class="separator:a3ee085c089155c088acd4ebb4ed41b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e83c722a3afb0c1ceda26c55c76e85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0e83c722a3afb0c1ceda26c55c76e85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ab0e83c722a3afb0c1ceda26c55c76e85">stopDiscovery</a> ()</td></tr>
<tr class="memdesc:ab0e83c722a3afb0c1ceda26c55c76e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">stopDiscovery stop sending discovery packets and go back to requesting state update packets only when in use. <br /></td></tr>
<tr class="separator:ab0e83c722a3afb0c1ceda26c55c76e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b5c67a3a87429a342fb9e82cdcaf6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ab5b5c67a3a87429a342fb9e82cdcaf6d">runningDiscovery</a> ()</td></tr>
<tr class="memdesc:ab5b5c67a3a87429a342fb9e82cdcaf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">runningDiscovery true if theres any controller that is going through the discovery routines and hasn't been discovered, false otherwise.  <a href="#ab5b5c67a3a87429a342fb9e82cdcaf6d">More...</a><br /></td></tr>
<tr class="separator:ab5b5c67a3a87429a342fb9e82cdcaf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e3ef4d4b075f7d53fcb6500c0d48e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ac8e3ef4d4b075f7d53fcb6500c0d48e1">addController</a> (QString controller)</td></tr>
<tr class="memdesc:ac8e3ef4d4b075f7d53fcb6500c0d48e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">addController attempts to add a new controller to the device table.  <a href="#ac8e3ef4d4b075f7d53fcb6500c0d48e1">More...</a><br /></td></tr>
<tr class="separator:ac8e3ef4d4b075f7d53fcb6500c0d48e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6ed7947ba8860ee31946d36d083944"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#aac6ed7947ba8860ee31946d36d083944">removeController</a> (QString controller)</td></tr>
<tr class="memdesc:aac6ed7947ba8860ee31946d36d083944"><td class="mdescLeft">&#160;</td><td class="mdescRight">removeController attempts to remove the controller from the device table.  <a href="#aac6ed7947ba8860ee31946d36d083944">More...</a><br /></td></tr>
<tr class="separator:aac6ed7947ba8860ee31946d36d083944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af821394409188dff6275f2810ca799ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#af821394409188dff6275f2810ca799ad">updateDevice</a> (SLightDevice device)</td></tr>
<tr class="memdesc:af821394409188dff6275f2810ca799ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateDevice update all the data in the light device that matches the same controller and index. if a light device doesn't exist with these properties, then it creates a new one.  <a href="#af821394409188dff6275f2810ca799ad">More...</a><br /></td></tr>
<tr class="separator:af821394409188dff6275f2810ca799ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d82da9a4b796ccb66d9d5c155e082e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a4d82da9a4b796ccb66d9d5c155e082e1">fillDevice</a> (SLightDevice &amp;device)</td></tr>
<tr class="memdesc:a4d82da9a4b796ccb66d9d5c155e082e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">fillDevice takes the controller and index of the referenced SLightDevice and overwrites all other values with the values stored in the device table.  <a href="#a4d82da9a4b796ccb66d9d5c155e082e1">More...</a><br /></td></tr>
<tr class="separator:a4d82da9a4b796ccb66d9d5c155e082e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1865d11bc8e1f01a925ed68e284691"><td class="memItemLeft" align="right" valign="top">const std::unordered_map<br class="typebreak" />
&lt; std::string, std::list<br class="typebreak" />
&lt; SLightDevice &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#acb1865d11bc8e1f01a925ed68e284691">deviceTable</a> ()</td></tr>
<tr class="memdesc:acb1865d11bc8e1f01a925ed68e284691"><td class="mdescLeft">&#160;</td><td class="mdescRight">deviceList list of the light devices  <a href="#acb1865d11bc8e1f01a925ed68e284691">More...</a><br /></td></tr>
<tr class="separator:acb1865d11bc8e1f01a925ed68e284691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa25ac27d5bdb85a13b8d461ca1a960c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#aaa25ac27d5bdb85a13b8d461ca1a960c">setupConnectionList</a> (ECommType type)</td></tr>
<tr class="memdesc:aaa25ac27d5bdb85a13b8d461ca1a960c"><td class="mdescLeft">&#160;</td><td class="mdescRight">setupConnectionList initializes the connection list and reloads it from system memory, if needed  <a href="#aaa25ac27d5bdb85a13b8d461ca1a960c">More...</a><br /></td></tr>
<tr class="separator:aaa25ac27d5bdb85a13b8d461ca1a960c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf39ac1fbdab41338549ea9010ed0f91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf39ac1fbdab41338549ea9010ed0f91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#acf39ac1fbdab41338549ea9010ed0f91">saveConnectionList</a> ()</td></tr>
<tr class="memdesc:acf39ac1fbdab41338549ea9010ed0f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">saveConnectionList must be called by deconstructors, saves the connection list to the app's persistent memory. <br /></td></tr>
<tr class="separator:acf39ac1fbdab41338549ea9010ed0f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adb4143fad9f0cad9b4e0efff68614bf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb4143fad9f0cad9b4e0efff68614bf1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#adb4143fad9f0cad9b4e0efff68614bf1">resetDiscovery</a> ()</td></tr>
<tr class="memdesc:adb4143fad9f0cad9b4e0efff68614bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">resetDiscovery clears the throttle list and discovery list and treats the commtype as if nothing has been discovered. <br /></td></tr>
<tr class="separator:adb4143fad9f0cad9b4e0efff68614bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b66737d5c7518453f138de385df52b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a5b66737d5c7518453f138de385df52b2">handleDiscoveryPacket</a> (QString sender, int throttleInterval, int throttleMax)</td></tr>
<tr class="memdesc:a5b66737d5c7518453f138de385df52b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">handleDiscoveryPacket called whenever a discovery packet is received by a commtype. Although all commtypes may received a packet in different ways or in differnt formats, all ways get converted so that they work with this function. The function determines if the device sending the discovery packet has been discovered already, and if it hasn't, it adds it to its list. It also initiates a throttle timer for this particular controller. Finally, it determines if its looking for any other controllers, and if its not, it shuts off the discovery timer.  <a href="#a5b66737d5c7518453f138de385df52b2">More...</a><br /></td></tr>
<tr class="separator:a5b66737d5c7518453f138de385df52b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab17df6d25cf2db9d844945d6f135e65c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab17df6d25cf2db9d844945d6f135e65c"></a>
std::unordered_map<br class="typebreak" />
&lt; std::string, std::list<br class="typebreak" />
&lt; SLightDevice &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#ab17df6d25cf2db9d844945d6f135e65c">mDeviceTable</a></td></tr>
<tr class="memdesc:ab17df6d25cf2db9d844945d6f135e65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">mDeviceTable hash table of all available devices. the hash key is the controller name and the list associated with it is all known devices connected to that controller. <br /></td></tr>
<tr class="separator:ab17df6d25cf2db9d844945d6f135e65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f88dea2ab73337cef428d5aed5fec6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35f88dea2ab73337cef428d5aed5fec6"></a>
std::list&lt; std::pair&lt; QString, <br class="typebreak" />
CommThrottle * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a35f88dea2ab73337cef428d5aed5fec6">mThrottleList</a></td></tr>
<tr class="memdesc:a35f88dea2ab73337cef428d5aed5fec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">mThrottleList list of throttles paired with strings. This allows each different discovered device to use a different throttle. <br /></td></tr>
<tr class="separator:a35f88dea2ab73337cef428d5aed5fec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72eb17fb724feb20de438b6c304e35ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72eb17fb724feb20de438b6c304e35ba"></a>
std::list&lt; QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a72eb17fb724feb20de438b6c304e35ba">mDiscoveryList</a></td></tr>
<tr class="memdesc:a72eb17fb724feb20de438b6c304e35ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">mDiscoveryList list of devices that have been discovered properly. <br /></td></tr>
<tr class="separator:a72eb17fb724feb20de438b6c304e35ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad0675d5baa960558751025bc5ec3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fad0675d5baa960558751025bc5ec3a"></a>
QTimer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a5fad0675d5baa960558751025bc5ec3a">mStateUpdateTimer</a></td></tr>
<tr class="memdesc:a5fad0675d5baa960558751025bc5ec3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">mStateUpdateTimer Polls the controller every few seconds requesting updates on all of its devices. <br /></td></tr>
<tr class="separator:a5fad0675d5baa960558751025bc5ec3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ba509a1aa972b772c1c6f8f074a1cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53ba509a1aa972b772c1c6f8f074a1cb"></a>
QTimer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a53ba509a1aa972b772c1c6f8f074a1cb">mDiscoveryTimer</a></td></tr>
<tr class="memdesc:a53ba509a1aa972b772c1c6f8f074a1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">mDiscoveryTimer used during discovery to poll the device every few seconds. <br /></td></tr>
<tr class="separator:a53ba509a1aa972b772c1c6f8f074a1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed07e124f1bb8819e0452cb2621e5629"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed07e124f1bb8819e0452cb2621e5629"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#aed07e124f1bb8819e0452cb2621e5629">mUpdateTimeoutInterval</a></td></tr>
<tr class="memdesc:aed07e124f1bb8819e0452cb2621e5629"><td class="mdescLeft">&#160;</td><td class="mdescRight">mUpdateTimeoutInterval number of msec that it takes the state update timer to time out and stop sending state update requests. <br /></td></tr>
<tr class="separator:aed07e124f1bb8819e0452cb2621e5629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc75099b138addb3dc35692e819eabe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcc75099b138addb3dc35692e819eabe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#afcc75099b138addb3dc35692e819eabe">mDiscoveryMode</a></td></tr>
<tr class="memdesc:afcc75099b138addb3dc35692e819eabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">mDiscoveryMode true if all discovery and state update threads for the commtype should be active, false if using the standard lifecyclef for all the threads. <br /></td></tr>
<tr class="separator:afcc75099b138addb3dc35692e819eabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8ea9e88347922939c9823e0f1488ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e8ea9e88347922939c9823e0f1488ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a2e8ea9e88347922939c9823e0f1488ea">mFullyDiscovered</a></td></tr>
<tr class="memdesc:a2e8ea9e88347922939c9823e0f1488ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">mFullyDiscovered bool that tracks whether or not all the controllers the commtype is looking for have been discovered. This gets set to false if a discovery routine starts looking for a new controller. <br /></td></tr>
<tr class="separator:a2e8ea9e88347922939c9823e0f1488ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a3020ab06d49b995e22c7b4567017e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47a3020ab06d49b995e22c7b4567017e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_comm_type.html#a47a3020ab06d49b995e22c7b4567017e">mHasStarted</a></td></tr>
<tr class="memdesc:a47a3020ab06d49b995e22c7b4567017e"><td class="mdescLeft">&#160;</td><td class="mdescRight">mHasStarted bool that tracks whether or not the <a class="el" href="class_comm_type.html#a78d309086195c52051f007e693ff2b7a" title="startup Each comm type has a series of threads that maintain the connection and check for changes...">startup()</a> routine has been called. Gets set to false after the <a class="el" href="class_comm_type.html#ad2a24398eeaafa49cd376cb09be961ef" title="shutdown turns off all threads that maintain the connection and check for changes. Also shuts down any discovery threads, if they are currently running. ">shutdown()</a> routine is callsed. <br /></td></tr>
<tr class="separator:a47a3020ab06d49b995e22c7b4567017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2015 - 2016. Released under the GNU General Public License. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac8e3ef4d4b075f7d53fcb6500c0d48e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommType::addController </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>controller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controller</td><td>the name of the new controller </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the controller is added, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="acb1865d11bc8e1f01a925ed68e284691"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;std::string, std::list&lt;SLightDevice&gt; &gt;&amp; CommType::deviceTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>list of the light devices </dd></dl>

</div>
</div>
<a class="anchor" id="a4d82da9a4b796ccb66d9d5c155e082e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommType::fillDevice </td>
          <td>(</td>
          <td class="paramtype">SLightDevice &amp;&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>a SLightDevice struct that has its index and controller filled in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if device is found and filled, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b66737d5c7518453f138de385df52b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommType::handleDiscoveryPacket </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>throttleInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>throttleMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>the controller that is sending the discovery packet. </td></tr>
    <tr><td class="paramname">throttleInterval</td><td>the amount of msec between each throttle restart </td></tr>
    <tr><td class="paramname">throttleMax</td><td>the total number of packets that can be sent in between each throttle restart. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace6d7465b678fc3daf1e9580d331c8dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CommType::hasStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if startup has been called and a shutdown has not be called after it, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aac6ed7947ba8860ee31946d36d083944"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommType::removeController </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>controller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connection</td><td>the connection you want to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the connection exists and was removed, false if it wasn't there in the first place </dd></dl>

</div>
</div>
<a class="anchor" id="ab5b5c67a3a87429a342fb9e82cdcaf6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CommType::runningDiscovery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if theres any controller that is going through the discovery routines and hasn't been discovered, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af6455a9e3aaa20b95077339fa5502ea7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CommType::sendPacket </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet that is going to be sent </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_comm_hue.html#a549a6fa8dfd50a1e241a538efc693376">CommHue</a>, <a class="el" href="class_comm_serial.html#ae46333922bcce379db388689ea778299">CommSerial</a>, <a class="el" href="class_comm_h_t_t_p.html#ad2f184165aad6a5efc1451e3bf0cdb2f">CommHTTP</a>, and <a class="el" href="class_comm_u_d_p.html#a2c890154588c04bea80749e004179c0f">CommUDP</a>.</p>

</div>
</div>
<a class="anchor" id="aaa25ac27d5bdb85a13b8d461ca1a960c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommType::setupConnectionList </td>
          <td>(</td>
          <td class="paramtype">ECommType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the ECommType of this specific connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af821394409188dff6275f2810ca799ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommType::updateDevice </td>
          <td>(</td>
          <td class="paramtype">SLightDevice&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>the new data for the light device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="commtype_8h_source.html">commtype.h</a></li>
<li>commtype.cpp</li>
</ul>
</div><!-- contents -->

<hr>
<table style="width:100%">
  <tr>
    <td>
      <p align="left">
      <small>
          &nbsp; &nbsp; LightingGUI Copyright 2015 - 2016  &nbsp; &nbsp; <br>
          &nbsp; &nbsp; All Rights MIT Licensed.  &nbsp; &nbsp; 
       </small>
       </p>
    </td>
    <td>
      <p align="right">
      <small>
          &nbsp; &nbsp;  Generated by doxygen 1.8.11  &nbsp; &nbsp;
       </small>
       </p>
    </td>
  </tr>
</table>
